
122A_ Final_Mouse.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800100  00001500  00001594  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001500  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000687  00800132  00800132  000015c6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000015c6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000015f8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001638  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000029a1  00000000  00000000  00001870  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010c5  00000000  00000000  00004211  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000018bd  00000000  00000000  000052d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000568  00000000  00000000  00006b94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e9f  00000000  00000000  000070fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000012e5  00000000  00000000  00007f9b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00009280  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4e c0       	rjmp	.+156    	; 0x9e <__ctors_end>
       2:	00 00       	nop
       4:	6a c0       	rjmp	.+212    	; 0xda <__bad_interrupt>
       6:	00 00       	nop
       8:	68 c0       	rjmp	.+208    	; 0xda <__bad_interrupt>
       a:	00 00       	nop
       c:	66 c0       	rjmp	.+204    	; 0xda <__bad_interrupt>
       e:	00 00       	nop
      10:	64 c0       	rjmp	.+200    	; 0xda <__bad_interrupt>
      12:	00 00       	nop
      14:	62 c0       	rjmp	.+196    	; 0xda <__bad_interrupt>
      16:	00 00       	nop
      18:	60 c0       	rjmp	.+192    	; 0xda <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5e c0       	rjmp	.+188    	; 0xda <__bad_interrupt>
      1e:	00 00       	nop
      20:	5c c0       	rjmp	.+184    	; 0xda <__bad_interrupt>
      22:	00 00       	nop
      24:	5a c0       	rjmp	.+180    	; 0xda <__bad_interrupt>
      26:	00 00       	nop
      28:	58 c0       	rjmp	.+176    	; 0xda <__bad_interrupt>
      2a:	00 00       	nop
      2c:	56 c0       	rjmp	.+172    	; 0xda <__bad_interrupt>
      2e:	00 00       	nop
      30:	54 c0       	rjmp	.+168    	; 0xda <__bad_interrupt>
      32:	00 00       	nop
      34:	37 c6       	rjmp	.+3182   	; 0xca4 <__vector_13>
      36:	00 00       	nop
      38:	50 c0       	rjmp	.+160    	; 0xda <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4e c0       	rjmp	.+156    	; 0xda <__bad_interrupt>
      3e:	00 00       	nop
      40:	4c c0       	rjmp	.+152    	; 0xda <__bad_interrupt>
      42:	00 00       	nop
      44:	4a c0       	rjmp	.+148    	; 0xda <__bad_interrupt>
      46:	00 00       	nop
      48:	48 c0       	rjmp	.+144    	; 0xda <__bad_interrupt>
      4a:	00 00       	nop
      4c:	46 c0       	rjmp	.+140    	; 0xda <__bad_interrupt>
      4e:	00 00       	nop
      50:	44 c0       	rjmp	.+136    	; 0xda <__bad_interrupt>
      52:	00 00       	nop
      54:	42 c0       	rjmp	.+132    	; 0xda <__bad_interrupt>
      56:	00 00       	nop
      58:	40 c0       	rjmp	.+128    	; 0xda <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3e c0       	rjmp	.+124    	; 0xda <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c1       	rjmp	.+640    	; 0x2e2 <__vector_24>
      62:	00 00       	nop
      64:	3a c0       	rjmp	.+116    	; 0xda <__bad_interrupt>
      66:	00 00       	nop
      68:	38 c0       	rjmp	.+112    	; 0xda <__bad_interrupt>
      6a:	00 00       	nop
      6c:	36 c0       	rjmp	.+108    	; 0xda <__bad_interrupt>
      6e:	00 00       	nop
      70:	34 c0       	rjmp	.+104    	; 0xda <__bad_interrupt>
      72:	00 00       	nop
      74:	32 c0       	rjmp	.+100    	; 0xda <__bad_interrupt>
      76:	00 00       	nop
      78:	30 c0       	rjmp	.+96     	; 0xda <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2e c0       	rjmp	.+92     	; 0xda <__bad_interrupt>
      7e:	00 00       	nop
      80:	2c c0       	rjmp	.+88     	; 0xda <__bad_interrupt>
      82:	00 00       	nop
      84:	2a c0       	rjmp	.+84     	; 0xda <__bad_interrupt>
      86:	00 00       	nop
      88:	28 c0       	rjmp	.+80     	; 0xda <__bad_interrupt>
      8a:	00 00       	nop
      8c:	bd 01       	movw	r22, r26
      8e:	c7 01       	movw	r24, r14
      90:	cb 01       	movw	r24, r22
      92:	f2 01       	movw	r30, r4
      94:	ff 01       	movw	r30, r30
      96:	0c 02       	muls	r16, r28
      98:	1d 02       	muls	r17, r29
      9a:	19 02       	muls	r17, r25
      9c:	a9 02       	muls	r26, r25

0000009e <__ctors_end>:
      9e:	11 24       	eor	r1, r1
      a0:	1f be       	out	0x3f, r1	; 63
      a2:	cf ef       	ldi	r28, 0xFF	; 255
      a4:	d0 e4       	ldi	r29, 0x40	; 64
      a6:	de bf       	out	0x3e, r29	; 62
      a8:	cd bf       	out	0x3d, r28	; 61

000000aa <__do_copy_data>:
      aa:	11 e0       	ldi	r17, 0x01	; 1
      ac:	a0 e0       	ldi	r26, 0x00	; 0
      ae:	b1 e0       	ldi	r27, 0x01	; 1
      b0:	e0 e0       	ldi	r30, 0x00	; 0
      b2:	f5 e1       	ldi	r31, 0x15	; 21
      b4:	00 e0       	ldi	r16, 0x00	; 0
      b6:	0b bf       	out	0x3b, r16	; 59
      b8:	02 c0       	rjmp	.+4      	; 0xbe <__do_copy_data+0x14>
      ba:	07 90       	elpm	r0, Z+
      bc:	0d 92       	st	X+, r0
      be:	a2 33       	cpi	r26, 0x32	; 50
      c0:	b1 07       	cpc	r27, r17
      c2:	d9 f7       	brne	.-10     	; 0xba <__do_copy_data+0x10>

000000c4 <__do_clear_bss>:
      c4:	27 e0       	ldi	r18, 0x07	; 7
      c6:	a2 e3       	ldi	r26, 0x32	; 50
      c8:	b1 e0       	ldi	r27, 0x01	; 1
      ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
      cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
      ce:	a9 3b       	cpi	r26, 0xB9	; 185
      d0:	b2 07       	cpc	r27, r18
      d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>
      d4:	84 d4       	rcall	.+2312   	; 0x9de <main>
      d6:	0c 94 7e 0a 	jmp	0x14fc	; 0x14fc <_exit>

000000da <__bad_interrupt>:
      da:	92 cf       	rjmp	.-220    	; 0x0 <__vectors>

000000dc <time>:
      dc:	fc 01       	movw	r30, r24
      de:	0f b6       	in	r0, 0x3f	; 63
      e0:	f8 94       	cli
      e2:	60 91 b5 07 	lds	r22, 0x07B5	; 0x8007b5 <__system_time>
      e6:	70 91 b6 07 	lds	r23, 0x07B6	; 0x8007b6 <__system_time+0x1>
      ea:	80 91 b7 07 	lds	r24, 0x07B7	; 0x8007b7 <__system_time+0x2>
      ee:	90 91 b8 07 	lds	r25, 0x07B8	; 0x8007b8 <__system_time+0x3>
      f2:	0f be       	out	0x3f, r0	; 63
      f4:	30 97       	sbiw	r30, 0x00	; 0
      f6:	21 f0       	breq	.+8      	; 0x100 <time+0x24>
      f8:	60 83       	st	Z, r22
      fa:	71 83       	std	Z+1, r23	; 0x01
      fc:	82 83       	std	Z+2, r24	; 0x02
      fe:	93 83       	std	Z+3, r25	; 0x03
     100:	08 95       	ret

00000102 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     102:	cf 93       	push	r28
     104:	df 93       	push	r29
     106:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     108:	20 d7       	rcall	.+3648   	; 0xf4a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     10a:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <__data_end>
     10e:	30 91 33 01 	lds	r19, 0x0133	; 0x800133 <__data_end+0x1>
     112:	ce 01       	movw	r24, r28
     114:	82 0f       	add	r24, r18
     116:	93 1f       	adc	r25, r19
     118:	8c 3d       	cpi	r24, 0xDC	; 220
     11a:	45 e0       	ldi	r20, 0x05	; 5
     11c:	94 07       	cpc	r25, r20
     11e:	58 f4       	brcc	.+22     	; 0x136 <pvPortMalloc+0x34>
     120:	28 17       	cp	r18, r24
     122:	39 07       	cpc	r19, r25
     124:	58 f4       	brcc	.+22     	; 0x13c <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     126:	e9 01       	movw	r28, r18
     128:	cc 5c       	subi	r28, 0xCC	; 204
     12a:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     12c:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <__data_end+0x1>
     130:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__data_end>
     134:	05 c0       	rjmp	.+10     	; 0x140 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     136:	c0 e0       	ldi	r28, 0x00	; 0
     138:	d0 e0       	ldi	r29, 0x00	; 0
     13a:	02 c0       	rjmp	.+4      	; 0x140 <pvPortMalloc+0x3e>
     13c:	c0 e0       	ldi	r28, 0x00	; 0
     13e:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     140:	cb d7       	rcall	.+3990   	; 0x10d8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     142:	ce 01       	movw	r24, r28
     144:	df 91       	pop	r29
     146:	cf 91       	pop	r28
     148:	08 95       	ret

0000014a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     14a:	08 95       	ret

0000014c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     14c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     14e:	03 96       	adiw	r24, 0x03	; 3
     150:	92 83       	std	Z+2, r25	; 0x02
     152:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     154:	2f ef       	ldi	r18, 0xFF	; 255
     156:	3f ef       	ldi	r19, 0xFF	; 255
     158:	34 83       	std	Z+4, r19	; 0x04
     15a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     15c:	96 83       	std	Z+6, r25	; 0x06
     15e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     160:	90 87       	std	Z+8, r25	; 0x08
     162:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     164:	10 82       	st	Z, r1
     166:	08 95       	ret

00000168 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     168:	fc 01       	movw	r30, r24
     16a:	11 86       	std	Z+9, r1	; 0x09
     16c:	10 86       	std	Z+8, r1	; 0x08
     16e:	08 95       	ret

00000170 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	fc 01       	movw	r30, r24
     176:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     178:	21 81       	ldd	r18, Z+1	; 0x01
     17a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     17c:	e9 01       	movw	r28, r18
     17e:	8a 81       	ldd	r24, Y+2	; 0x02
     180:	9b 81       	ldd	r25, Y+3	; 0x03
     182:	13 96       	adiw	r26, 0x03	; 3
     184:	9c 93       	st	X, r25
     186:	8e 93       	st	-X, r24
     188:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     18a:	81 81       	ldd	r24, Z+1	; 0x01
     18c:	92 81       	ldd	r25, Z+2	; 0x02
     18e:	15 96       	adiw	r26, 0x05	; 5
     190:	9c 93       	st	X, r25
     192:	8e 93       	st	-X, r24
     194:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     196:	8a 81       	ldd	r24, Y+2	; 0x02
     198:	9b 81       	ldd	r25, Y+3	; 0x03
     19a:	ec 01       	movw	r28, r24
     19c:	7d 83       	std	Y+5, r23	; 0x05
     19e:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     1a0:	e9 01       	movw	r28, r18
     1a2:	7b 83       	std	Y+3, r23	; 0x03
     1a4:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     1a6:	72 83       	std	Z+2, r23	; 0x02
     1a8:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1aa:	19 96       	adiw	r26, 0x09	; 9
     1ac:	fc 93       	st	X, r31
     1ae:	ee 93       	st	-X, r30
     1b0:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     1b2:	80 81       	ld	r24, Z
     1b4:	8f 5f       	subi	r24, 0xFF	; 255
     1b6:	80 83       	st	Z, r24
}
     1b8:	df 91       	pop	r29
     1ba:	cf 91       	pop	r28
     1bc:	08 95       	ret

000001be <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     1be:	cf 93       	push	r28
     1c0:	df 93       	push	r29
     1c2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     1c4:	48 81       	ld	r20, Y
     1c6:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     1c8:	4f 3f       	cpi	r20, 0xFF	; 255
     1ca:	2f ef       	ldi	r18, 0xFF	; 255
     1cc:	52 07       	cpc	r21, r18
     1ce:	31 f4       	brne	.+12     	; 0x1dc <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     1d0:	dc 01       	movw	r26, r24
     1d2:	17 96       	adiw	r26, 0x07	; 7
     1d4:	ed 91       	ld	r30, X+
     1d6:	fc 91       	ld	r31, X
     1d8:	18 97       	sbiw	r26, 0x08	; 8
     1da:	17 c0       	rjmp	.+46     	; 0x20a <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     1dc:	fc 01       	movw	r30, r24
     1de:	33 96       	adiw	r30, 0x03	; 3
     1e0:	dc 01       	movw	r26, r24
     1e2:	15 96       	adiw	r26, 0x05	; 5
     1e4:	2d 91       	ld	r18, X+
     1e6:	3c 91       	ld	r19, X
     1e8:	16 97       	sbiw	r26, 0x06	; 6
     1ea:	d9 01       	movw	r26, r18
     1ec:	2d 91       	ld	r18, X+
     1ee:	3c 91       	ld	r19, X
     1f0:	42 17       	cp	r20, r18
     1f2:	53 07       	cpc	r21, r19
     1f4:	50 f0       	brcs	.+20     	; 0x20a <vListInsert+0x4c>
     1f6:	02 80       	ldd	r0, Z+2	; 0x02
     1f8:	f3 81       	ldd	r31, Z+3	; 0x03
     1fa:	e0 2d       	mov	r30, r0
     1fc:	a2 81       	ldd	r26, Z+2	; 0x02
     1fe:	b3 81       	ldd	r27, Z+3	; 0x03
     200:	2d 91       	ld	r18, X+
     202:	3c 91       	ld	r19, X
     204:	42 17       	cp	r20, r18
     206:	53 07       	cpc	r21, r19
     208:	b0 f7       	brcc	.-20     	; 0x1f6 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     20a:	a2 81       	ldd	r26, Z+2	; 0x02
     20c:	b3 81       	ldd	r27, Z+3	; 0x03
     20e:	bb 83       	std	Y+3, r27	; 0x03
     210:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     212:	15 96       	adiw	r26, 0x05	; 5
     214:	dc 93       	st	X, r29
     216:	ce 93       	st	-X, r28
     218:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     21a:	fd 83       	std	Y+5, r31	; 0x05
     21c:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     21e:	d3 83       	std	Z+3, r29	; 0x03
     220:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     222:	99 87       	std	Y+9, r25	; 0x09
     224:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     226:	fc 01       	movw	r30, r24
     228:	20 81       	ld	r18, Z
     22a:	2f 5f       	subi	r18, 0xFF	; 255
     22c:	20 83       	st	Z, r18
}
     22e:	df 91       	pop	r29
     230:	cf 91       	pop	r28
     232:	08 95       	ret

00000234 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     234:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     236:	a2 81       	ldd	r26, Z+2	; 0x02
     238:	b3 81       	ldd	r27, Z+3	; 0x03
     23a:	84 81       	ldd	r24, Z+4	; 0x04
     23c:	95 81       	ldd	r25, Z+5	; 0x05
     23e:	15 96       	adiw	r26, 0x05	; 5
     240:	9c 93       	st	X, r25
     242:	8e 93       	st	-X, r24
     244:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     246:	a4 81       	ldd	r26, Z+4	; 0x04
     248:	b5 81       	ldd	r27, Z+5	; 0x05
     24a:	82 81       	ldd	r24, Z+2	; 0x02
     24c:	93 81       	ldd	r25, Z+3	; 0x03
     24e:	13 96       	adiw	r26, 0x03	; 3
     250:	9c 93       	st	X, r25
     252:	8e 93       	st	-X, r24
     254:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     256:	a0 85       	ldd	r26, Z+8	; 0x08
     258:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     25a:	11 96       	adiw	r26, 0x01	; 1
     25c:	8d 91       	ld	r24, X+
     25e:	9c 91       	ld	r25, X
     260:	12 97       	sbiw	r26, 0x02	; 2
     262:	8e 17       	cp	r24, r30
     264:	9f 07       	cpc	r25, r31
     266:	31 f4       	brne	.+12     	; 0x274 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     268:	84 81       	ldd	r24, Z+4	; 0x04
     26a:	95 81       	ldd	r25, Z+5	; 0x05
     26c:	12 96       	adiw	r26, 0x02	; 2
     26e:	9c 93       	st	X, r25
     270:	8e 93       	st	-X, r24
     272:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     274:	11 86       	std	Z+9, r1	; 0x09
     276:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     278:	8c 91       	ld	r24, X
     27a:	81 50       	subi	r24, 0x01	; 1
     27c:	8c 93       	st	X, r24
     27e:	08 95       	ret

00000280 <USART_IsSendReady>:
void TRACK_Init(){
	trackData = INITTrack;
}

void EMIT_Init(){
	emitLight = INITEmit;
     280:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     284:	80 72       	andi	r24, 0x20	; 32
     286:	08 95       	ret

00000288 <USART_Flush>:
     288:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     28c:	88 23       	and	r24, r24
     28e:	54 f4       	brge	.+20     	; 0x2a4 <USART_Flush+0x1c>
     290:	a6 ec       	ldi	r26, 0xC6	; 198
     292:	b0 e0       	ldi	r27, 0x00	; 0
     294:	e0 ec       	ldi	r30, 0xC0	; 192
     296:	f0 e0       	ldi	r31, 0x00	; 0
     298:	8c 91       	ld	r24, X
     29a:	80 93 10 07 	sts	0x0710, r24	; 0x800710 <dummy.2415>
     29e:	80 81       	ld	r24, Z
     2a0:	88 23       	and	r24, r24
     2a2:	d4 f3       	brlt	.-12     	; 0x298 <USART_Flush+0x10>
     2a4:	08 95       	ret

000002a6 <USART_Send>:
     2a6:	e0 ec       	ldi	r30, 0xC0	; 192
     2a8:	f0 e0       	ldi	r31, 0x00	; 0
     2aa:	90 81       	ld	r25, Z
     2ac:	95 ff       	sbrs	r25, 5
     2ae:	fd cf       	rjmp	.-6      	; 0x2aa <USART_Send+0x4>
     2b0:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     2b4:	08 95       	ret

000002b6 <ADC_init>:
     2b6:	ea e7       	ldi	r30, 0x7A	; 122
     2b8:	f0 e0       	ldi	r31, 0x00	; 0
     2ba:	80 81       	ld	r24, Z
     2bc:	88 6e       	ori	r24, 0xE8	; 232
     2be:	80 83       	st	Z, r24
     2c0:	08 95       	ret

000002c2 <adc_read>:
     2c2:	ec e7       	ldi	r30, 0x7C	; 124
     2c4:	f0 e0       	ldi	r31, 0x00	; 0
     2c6:	90 81       	ld	r25, Z
     2c8:	98 7f       	andi	r25, 0xF8	; 248
     2ca:	89 2b       	or	r24, r25
     2cc:	80 83       	st	Z, r24
     2ce:	ea e7       	ldi	r30, 0x7A	; 122
     2d0:	f0 e0       	ldi	r31, 0x00	; 0
     2d2:	80 81       	ld	r24, Z
     2d4:	80 64       	ori	r24, 0x40	; 64
     2d6:	80 83       	st	Z, r24
     2d8:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     2dc:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     2e0:	08 95       	ret

000002e2 <__vector_24>:
     2e2:	1f 92       	push	r1
     2e4:	0f 92       	push	r0
     2e6:	0f b6       	in	r0, 0x3f	; 63
     2e8:	0f 92       	push	r0
     2ea:	11 24       	eor	r1, r1
     2ec:	8f 93       	push	r24
     2ee:	81 e0       	ldi	r24, 0x01	; 1
     2f0:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <ADC_Flag>
     2f4:	8f 91       	pop	r24
     2f6:	0f 90       	pop	r0
     2f8:	0f be       	out	0x3f, r0	; 63
     2fa:	0f 90       	pop	r0
     2fc:	1f 90       	pop	r1
     2fe:	18 95       	reti

00000300 <MOVE_Tick>:
}

void MOVE_Tick(){
     300:	cf 93       	push	r28
     302:	df 93       	push	r29
	//Actions
	switch(moveMouse){
     304:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <moveMouse>
     308:	84 30       	cpi	r24, 0x04	; 4
     30a:	c9 f0       	breq	.+50     	; 0x33e <MOVE_Tick+0x3e>
     30c:	28 f4       	brcc	.+10     	; 0x318 <MOVE_Tick+0x18>
     30e:	88 23       	and	r24, r24
     310:	51 f0       	breq	.+20     	; 0x326 <MOVE_Tick+0x26>
     312:	83 30       	cpi	r24, 0x03	; 3
     314:	89 f0       	breq	.+34     	; 0x338 <MOVE_Tick+0x38>
     316:	25 c0       	rjmp	.+74     	; 0x362 <MOVE_Tick+0x62>
     318:	87 30       	cpi	r24, 0x07	; 7
     31a:	d1 f0       	breq	.+52     	; 0x350 <MOVE_Tick+0x50>
     31c:	88 30       	cpi	r24, 0x08	; 8
     31e:	e9 f0       	breq	.+58     	; 0x35a <MOVE_Tick+0x5a>
     320:	86 30       	cpi	r24, 0x06	; 6
     322:	f9 f4       	brne	.+62     	; 0x362 <MOVE_Tick+0x62>
     324:	0f c0       	rjmp	.+30     	; 0x344 <MOVE_Tick+0x44>
		case INIT:
			
			srand(time(0));
     326:	80 e0       	ldi	r24, 0x00	; 0
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	d8 de       	rcall	.-592    	; 0xdc <time>
     32c:	cb 01       	movw	r24, r22
     32e:	0e 94 00 0a 	call	0x1400	; 0x1400 <srand>
			//char where = "";
			PORTC = 0x11;
     332:	81 e1       	ldi	r24, 0x11	; 17
     334:	88 b9       	out	0x08, r24	; 8
			break;
     336:	15 c0       	rjmp	.+42     	; 0x362 <MOVE_Tick+0x62>
		case check:  ;
			
			break;
		case left:  // turn left
			//where = "left";
			PORTC = 0x53;
     338:	83 e5       	ldi	r24, 0x53	; 83
     33a:	88 b9       	out	0x08, r24	; 8
			break;
     33c:	12 c0       	rjmp	.+36     	; 0x362 <MOVE_Tick+0x62>
		case right: // turn right
			//where = "right;"
			PORTC = 0x35;
     33e:	85 e3       	ldi	r24, 0x35	; 53
     340:	88 b9       	out	0x08, r24	; 8
			break;
     342:	0f c0       	rjmp	.+30     	; 0x362 <MOVE_Tick+0x62>
		case turnAround: // turn around
			//where = "back";
			break;
		case forward: // move forward
			PORTC = 0x33;
     344:	83 e3       	ldi	r24, 0x33	; 51
     346:	88 b9       	out	0x08, r24	; 8
			vTaskDelay(200);
     348:	88 ec       	ldi	r24, 0xC8	; 200
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	46 d7       	rcall	.+3724   	; 0x11da <vTaskDelay>
			break;
     34e:	09 c0       	rjmp	.+18     	; 0x362 <MOVE_Tick+0x62>
		case turnWait:
			PORTC = 0x00;
     350:	18 b8       	out	0x08, r1	; 8
			vTaskDelay(200);
     352:	88 ec       	ldi	r24, 0xC8	; 200
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	41 d7       	rcall	.+3714   	; 0x11da <vTaskDelay>
			break;
     358:	04 c0       	rjmp	.+8      	; 0x362 <MOVE_Tick+0x62>
		case forwardWait:
			PORTC = 0x00;	
     35a:	18 b8       	out	0x08, r1	; 8
			vTaskDelay(200);
     35c:	88 ec       	ldi	r24, 0xC8	; 200
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	3c d7       	rcall	.+3704   	; 0x11da <vTaskDelay>
			break;
		//trackData = setData;
	}
	//Transitions
	switch(moveMouse){
     362:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <moveMouse>
     366:	8e 2f       	mov	r24, r30
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	89 30       	cpi	r24, 0x09	; 9
     36c:	91 05       	cpc	r25, r1
     36e:	08 f0       	brcs	.+2      	; 0x372 <MOVE_Tick+0x72>
     370:	f3 c0       	rjmp	.+486    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
     372:	fc 01       	movw	r30, r24
     374:	ea 5b       	subi	r30, 0xBA	; 186
     376:	ff 4f       	sbci	r31, 0xFF	; 255
     378:	f0 c7       	rjmp	.+4064   	; 0x135a <__tablejump2__>
		case INIT:
			//moveMouse = waitStart;
			data[0][0] = 1;
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	90 93 19 07 	sts	0x0719, r25	; 0x800719 <data+0x1>
     382:	80 93 18 07 	sts	0x0718, r24	; 0x800718 <data>
			moveMouse = forward;
     386:	86 e0       	ldi	r24, 0x06	; 6
     388:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			break;
     38c:	e5 c0       	rjmp	.+458    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case waitStart:
			//moveMouse = check;
			moveMouse = forward;
     38e:	86 e0       	ldi	r24, 0x06	; 6
     390:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			break;
     394:	e1 c0       	rjmp	.+450    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case check: ;
			ADC_init();
     396:	8f df       	rcall	.-226    	; 0x2b6 <ADC_init>
			int adcL = adc_read(0);		// read adc value at PA0
     398:	80 e0       	ldi	r24, 0x00	; 0
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	92 df       	rcall	.-220    	; 0x2c2 <adc_read>
     39e:	ec 01       	movw	r28, r24
			while(!ADC_Flag){} ADC_Flag = 0;
     3a0:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <ADC_Flag>
     3a4:	99 23       	and	r25, r25
     3a6:	e1 f3       	breq	.-8      	; 0x3a0 <MOVE_Tick+0xa0>
     3a8:	10 92 11 07 	sts	0x0711, r1	; 0x800711 <ADC_Flag>
			int adcR = adc_read(1);		// read adc value at PA1
     3ac:	81 e0       	ldi	r24, 0x01	; 1
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	88 df       	rcall	.-240    	; 0x2c2 <adc_read>
			while(!ADC_Flag){} ADC_Flag = 0;
     3b2:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <ADC_Flag>
     3b6:	99 23       	and	r25, r25
     3b8:	e1 f3       	breq	.-8      	; 0x3b2 <MOVE_Tick+0xb2>
     3ba:	10 92 11 07 	sts	0x0711, r1	; 0x800711 <ADC_Flag>
			int adcF = adc_read(2);		// read adc value at PA2
     3be:	82 e0       	ldi	r24, 0x02	; 2
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	7f df       	rcall	.-258    	; 0x2c2 <adc_read>
			while(!ADC_Flag){} ADC_Flag = 0;
     3c4:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <ADC_Flag>
     3c8:	99 23       	and	r25, r25
     3ca:	e1 f3       	breq	.-8      	; 0x3c4 <MOVE_Tick+0xc4>
     3cc:	10 92 11 07 	sts	0x0711, r1	; 0x800711 <ADC_Flag>
			PORTD = 0xFF;
     3d0:	8f ef       	ldi	r24, 0xFF	; 255
     3d2:	8b b9       	out	0x0b, r24	; 11
			}
			else{  // turn around
			
			}*/
			
			if(adcL == 1008){  // left wall empty
     3d4:	c0 3f       	cpi	r28, 0xF0	; 240
     3d6:	d3 40       	sbci	r29, 0x03	; 3
     3d8:	09 f0       	breq	.+2      	; 0x3dc <MOVE_Tick+0xdc>
     3da:	be c0       	rjmp	.+380    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
				moveMouse = left;
     3dc:	83 e0       	ldi	r24, 0x03	; 3
     3de:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
     3e2:	ba c0       	rjmp	.+372    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
			else{
				moveMouse = forward;
			}*/
			break;
		case left:
			dir += 1;
     3e4:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <dir>
     3e8:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <dir+0x1>
     3ec:	01 96       	adiw	r24, 0x01	; 1
     3ee:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <dir+0x1>
     3f2:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <dir>
			moveMouse = turnWait;
     3f6:	87 e0       	ldi	r24, 0x07	; 7
     3f8:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			//moveMouse = right;
			break;
     3fc:	ad c0       	rjmp	.+346    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case right:
			dir -= 1;
     3fe:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <dir>
     402:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <dir+0x1>
     406:	01 97       	sbiw	r24, 0x01	; 1
     408:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <dir+0x1>
     40c:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <dir>
			moveMouse = turnWait;
     410:	87 e0       	ldi	r24, 0x07	; 7
     412:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			break;
     416:	a0 c0       	rjmp	.+320    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case turnAround:
			dir += 2;
     418:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <dir>
     41c:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <dir+0x1>
     420:	02 96       	adiw	r24, 0x02	; 2
     422:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <dir+0x1>
     426:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <dir>
			moveMouse = turnWait;
     42a:	87 e0       	ldi	r24, 0x07	; 7
     42c:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			break;
     430:	93 c0       	rjmp	.+294    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case turnWait:
			moveMouse = forward;
     432:	86 e0       	ldi	r24, 0x06	; 6
     434:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			break;
     438:	8f c0       	rjmp	.+286    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case forward:
			if(dir%4 == 0){
     43a:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <dir>
     43e:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <dir+0x1>
     442:	9c 01       	movw	r18, r24
     444:	23 70       	andi	r18, 0x03	; 3
     446:	33 27       	eor	r19, r19
     448:	23 2b       	or	r18, r19
     44a:	e1 f4       	brne	.+56     	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
				k += 1;
     44c:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <k>
     450:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <k+0x1>
     454:	01 96       	adiw	r24, 0x01	; 1
     456:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <k+0x1>
     45a:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <k>
				data[j][k] = 1;
     45e:	e0 91 92 07 	lds	r30, 0x0792	; 0x800792 <j>
     462:	f0 91 93 07 	lds	r31, 0x0793	; 0x800793 <j+0x1>
     466:	ee 0f       	add	r30, r30
     468:	ff 1f       	adc	r31, r31
     46a:	ee 0f       	add	r30, r30
     46c:	ff 1f       	adc	r31, r31
     46e:	e8 0f       	add	r30, r24
     470:	f9 1f       	adc	r31, r25
     472:	ee 0f       	add	r30, r30
     474:	ff 1f       	adc	r31, r31
     476:	e8 5e       	subi	r30, 0xE8	; 232
     478:	f8 4f       	sbci	r31, 0xF8	; 248
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	90 e0       	ldi	r25, 0x00	; 0
     47e:	91 83       	std	Z+1, r25	; 0x01
     480:	80 83       	st	Z, r24
     482:	63 c0       	rjmp	.+198    	; 0x54a <__LOCK_REGION_LENGTH__+0x14a>
			}
			else if(dir%4 == 1){
     484:	83 70       	andi	r24, 0x03	; 3
     486:	90 78       	andi	r25, 0x80	; 128
     488:	99 23       	and	r25, r25
     48a:	24 f4       	brge	.+8      	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
     48c:	01 97       	sbiw	r24, 0x01	; 1
     48e:	8c 6f       	ori	r24, 0xFC	; 252
     490:	9f 6f       	ori	r25, 0xFF	; 255
     492:	01 96       	adiw	r24, 0x01	; 1
     494:	81 30       	cpi	r24, 0x01	; 1
     496:	91 05       	cpc	r25, r1
     498:	e1 f4       	brne	.+56     	; 0x4d2 <__LOCK_REGION_LENGTH__+0xd2>
				j += 1;
     49a:	e0 91 92 07 	lds	r30, 0x0792	; 0x800792 <j>
     49e:	f0 91 93 07 	lds	r31, 0x0793	; 0x800793 <j+0x1>
     4a2:	31 96       	adiw	r30, 0x01	; 1
     4a4:	f0 93 93 07 	sts	0x0793, r31	; 0x800793 <j+0x1>
     4a8:	e0 93 92 07 	sts	0x0792, r30	; 0x800792 <j>
				data[j][k] = 1;
     4ac:	ee 0f       	add	r30, r30
     4ae:	ff 1f       	adc	r31, r31
     4b0:	ee 0f       	add	r30, r30
     4b2:	ff 1f       	adc	r31, r31
     4b4:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <k>
     4b8:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <k+0x1>
     4bc:	e8 0f       	add	r30, r24
     4be:	f9 1f       	adc	r31, r25
     4c0:	ee 0f       	add	r30, r30
     4c2:	ff 1f       	adc	r31, r31
     4c4:	e8 5e       	subi	r30, 0xE8	; 232
     4c6:	f8 4f       	sbci	r31, 0xF8	; 248
     4c8:	81 e0       	ldi	r24, 0x01	; 1
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	91 83       	std	Z+1, r25	; 0x01
     4ce:	80 83       	st	Z, r24
     4d0:	3c c0       	rjmp	.+120    	; 0x54a <__LOCK_REGION_LENGTH__+0x14a>
			}
			else if(dir%4 == 2){
     4d2:	82 30       	cpi	r24, 0x02	; 2
     4d4:	91 05       	cpc	r25, r1
     4d6:	e1 f4       	brne	.+56     	; 0x510 <__LOCK_REGION_LENGTH__+0x110>
				k -= 1;
     4d8:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <k>
     4dc:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <k+0x1>
     4e0:	01 97       	sbiw	r24, 0x01	; 1
     4e2:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <k+0x1>
     4e6:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <k>
				data[j][k] = 1;
     4ea:	e0 91 92 07 	lds	r30, 0x0792	; 0x800792 <j>
     4ee:	f0 91 93 07 	lds	r31, 0x0793	; 0x800793 <j+0x1>
     4f2:	ee 0f       	add	r30, r30
     4f4:	ff 1f       	adc	r31, r31
     4f6:	ee 0f       	add	r30, r30
     4f8:	ff 1f       	adc	r31, r31
     4fa:	e8 0f       	add	r30, r24
     4fc:	f9 1f       	adc	r31, r25
     4fe:	ee 0f       	add	r30, r30
     500:	ff 1f       	adc	r31, r31
     502:	e8 5e       	subi	r30, 0xE8	; 232
     504:	f8 4f       	sbci	r31, 0xF8	; 248
     506:	81 e0       	ldi	r24, 0x01	; 1
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	91 83       	std	Z+1, r25	; 0x01
     50c:	80 83       	st	Z, r24
     50e:	1d c0       	rjmp	.+58     	; 0x54a <__LOCK_REGION_LENGTH__+0x14a>
			}
			else if(dir%4 == 3){
     510:	03 97       	sbiw	r24, 0x03	; 3
     512:	d9 f4       	brne	.+54     	; 0x54a <__LOCK_REGION_LENGTH__+0x14a>
				j -= 1;
     514:	e0 91 92 07 	lds	r30, 0x0792	; 0x800792 <j>
     518:	f0 91 93 07 	lds	r31, 0x0793	; 0x800793 <j+0x1>
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	f0 93 93 07 	sts	0x0793, r31	; 0x800793 <j+0x1>
     522:	e0 93 92 07 	sts	0x0792, r30	; 0x800792 <j>
				data[j][k] = 1;
     526:	ee 0f       	add	r30, r30
     528:	ff 1f       	adc	r31, r31
     52a:	ee 0f       	add	r30, r30
     52c:	ff 1f       	adc	r31, r31
     52e:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <k>
     532:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <k+0x1>
     536:	e8 0f       	add	r30, r24
     538:	f9 1f       	adc	r31, r25
     53a:	ee 0f       	add	r30, r30
     53c:	ff 1f       	adc	r31, r31
     53e:	e8 5e       	subi	r30, 0xE8	; 232
     540:	f8 4f       	sbci	r31, 0xF8	; 248
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	91 83       	std	Z+1, r25	; 0x01
     548:	80 83       	st	Z, r24
			}
			
			moveMouse = forwardWait;
     54a:	88 e0       	ldi	r24, 0x08	; 8
     54c:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			//moveMouse = left;
			break;
     550:	03 c0       	rjmp	.+6      	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
		case forwardWait:
			moveMouse = check;
     552:	82 e0       	ldi	r24, 0x02	; 2
     554:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <moveMouse>
			break;
		
	}
}
     558:	df 91       	pop	r29
     55a:	cf 91       	pop	r28
     55c:	08 95       	ret

0000055e <MoveSecTask>:
ISR(ADC_vect){
	ADC_Flag = 1;
}

void MOVE_Init(){
	moveMouse = INIT;
     55e:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <moveMouse>
void MoveSecTask()
{
	MOVE_Init();	
   for(;;) 
   { 	
	MOVE_Tick();
     562:	ce de       	rcall	.-612    	; 0x300 <MOVE_Tick>
	vTaskDelay(200); 
     564:	88 ec       	ldi	r24, 0xC8	; 200
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	38 d6       	rcall	.+3184   	; 0x11da <vTaskDelay>
   } 
     56a:	fb cf       	rjmp	.-10     	; 0x562 <MoveSecTask+0x4>

0000056c <TRACK_Tick>:
}


void TRACK_Tick(){
	//Actions
	switch(trackData){
     56c:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <trackData>
     570:	81 30       	cpi	r24, 0x01	; 1
     572:	09 f0       	breq	.+2      	; 0x576 <TRACK_Tick+0xa>
     574:	ca c1       	rjmp	.+916    	; 0x90a <TRACK_Tick+0x39e>
		case INITTrack:
			break;
		case send:  // USART send new change
			//check each value in matrix and add to the send value if it hasn't already been added to.
			if(data[0][0] == 1 && flag1 == 0){
     576:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <data>
     57a:	90 91 19 07 	lds	r25, 0x0719	; 0x800719 <data+0x1>
     57e:	01 97       	sbiw	r24, 0x01	; 1
     580:	b1 f4       	brne	.+44     	; 0x5ae <TRACK_Tick+0x42>
     582:	80 91 a3 07 	lds	r24, 0x07A3	; 0x8007a3 <flag1>
     586:	90 91 a4 07 	lds	r25, 0x07A4	; 0x8007a4 <flag1+0x1>
     58a:	89 2b       	or	r24, r25
     58c:	81 f4       	brne	.+32     	; 0x5ae <TRACK_Tick+0x42>
				sendValue += 1;
     58e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     592:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     596:	01 96       	adiw	r24, 0x01	; 1
     598:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     59c:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag1 = 1;
     5a0:	81 e0       	ldi	r24, 0x01	; 1
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	90 93 a4 07 	sts	0x07A4, r25	; 0x8007a4 <flag1+0x1>
     5a8:	80 93 a3 07 	sts	0x07A3, r24	; 0x8007a3 <flag1>
     5ac:	a3 c1       	rjmp	.+838    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[0][1] == 1 && flag2 == 0){
     5ae:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <data+0x2>
     5b2:	90 91 1b 07 	lds	r25, 0x071B	; 0x80071b <data+0x3>
     5b6:	01 97       	sbiw	r24, 0x01	; 1
     5b8:	b1 f4       	brne	.+44     	; 0x5e6 <TRACK_Tick+0x7a>
     5ba:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <flag2>
     5be:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <flag2+0x1>
     5c2:	89 2b       	or	r24, r25
     5c4:	81 f4       	brne	.+32     	; 0x5e6 <TRACK_Tick+0x7a>
				sendValue += 2;
     5c6:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     5ca:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     5ce:	02 96       	adiw	r24, 0x02	; 2
     5d0:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     5d4:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag2 = 1;
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	90 93 9d 07 	sts	0x079D, r25	; 0x80079d <flag2+0x1>
     5e0:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <flag2>
     5e4:	87 c1       	rjmp	.+782    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[0][2] == 1 && flag3 == 0){
     5e6:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <data+0x4>
     5ea:	90 91 1d 07 	lds	r25, 0x071D	; 0x80071d <data+0x5>
     5ee:	01 97       	sbiw	r24, 0x01	; 1
     5f0:	b1 f4       	brne	.+44     	; 0x61e <TRACK_Tick+0xb2>
     5f2:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <flag3>
     5f6:	90 91 b0 07 	lds	r25, 0x07B0	; 0x8007b0 <flag3+0x1>
     5fa:	89 2b       	or	r24, r25
     5fc:	81 f4       	brne	.+32     	; 0x61e <TRACK_Tick+0xb2>
				sendValue += 3;
     5fe:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     602:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     606:	03 96       	adiw	r24, 0x03	; 3
     608:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     60c:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag3 = 1;
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	90 93 b0 07 	sts	0x07B0, r25	; 0x8007b0 <flag3+0x1>
     618:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <flag3>
     61c:	6b c1       	rjmp	.+726    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[0][3] == 1 && flag4 == 0){
     61e:	80 91 1e 07 	lds	r24, 0x071E	; 0x80071e <data+0x6>
     622:	90 91 1f 07 	lds	r25, 0x071F	; 0x80071f <data+0x7>
     626:	01 97       	sbiw	r24, 0x01	; 1
     628:	b1 f4       	brne	.+44     	; 0x656 <TRACK_Tick+0xea>
     62a:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <flag4>
     62e:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <flag4+0x1>
     632:	89 2b       	or	r24, r25
     634:	81 f4       	brne	.+32     	; 0x656 <TRACK_Tick+0xea>
				sendValue += 4;
     636:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     63a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     63e:	04 96       	adiw	r24, 0x04	; 4
     640:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     644:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag4 = 1;
     648:	81 e0       	ldi	r24, 0x01	; 1
     64a:	90 e0       	ldi	r25, 0x00	; 0
     64c:	90 93 9f 07 	sts	0x079F, r25	; 0x80079f <flag4+0x1>
     650:	80 93 9e 07 	sts	0x079E, r24	; 0x80079e <flag4>
     654:	4f c1       	rjmp	.+670    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[1][0] == 1 && flag5 == 0){
     656:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <data+0x8>
     65a:	90 91 21 07 	lds	r25, 0x0721	; 0x800721 <data+0x9>
     65e:	01 97       	sbiw	r24, 0x01	; 1
     660:	b1 f4       	brne	.+44     	; 0x68e <TRACK_Tick+0x122>
     662:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <flag5>
     666:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <flag5+0x1>
     66a:	89 2b       	or	r24, r25
     66c:	81 f4       	brne	.+32     	; 0x68e <TRACK_Tick+0x122>
				sendValue += 5;
     66e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     672:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     676:	05 96       	adiw	r24, 0x05	; 5
     678:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     67c:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag5 = 1;
     680:	81 e0       	ldi	r24, 0x01	; 1
     682:	90 e0       	ldi	r25, 0x00	; 0
     684:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <flag5+0x1>
     688:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <flag5>
     68c:	33 c1       	rjmp	.+614    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[1][1] == 1 && flag6 == 0){
     68e:	80 91 22 07 	lds	r24, 0x0722	; 0x800722 <data+0xa>
     692:	90 91 23 07 	lds	r25, 0x0723	; 0x800723 <data+0xb>
     696:	01 97       	sbiw	r24, 0x01	; 1
     698:	b1 f4       	brne	.+44     	; 0x6c6 <TRACK_Tick+0x15a>
     69a:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <flag6>
     69e:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <flag6+0x1>
     6a2:	89 2b       	or	r24, r25
     6a4:	81 f4       	brne	.+32     	; 0x6c6 <TRACK_Tick+0x15a>
				sendValue += 6;
     6a6:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     6aa:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     6ae:	06 96       	adiw	r24, 0x06	; 6
     6b0:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     6b4:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag6 = 1;
     6b8:	81 e0       	ldi	r24, 0x01	; 1
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <flag6+0x1>
     6c0:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <flag6>
     6c4:	17 c1       	rjmp	.+558    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[1][2] == 1 && flag7 == 0){
     6c6:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <data+0xc>
     6ca:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <data+0xd>
     6ce:	01 97       	sbiw	r24, 0x01	; 1
     6d0:	b1 f4       	brne	.+44     	; 0x6fe <TRACK_Tick+0x192>
     6d2:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <flag7>
     6d6:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <flag7+0x1>
     6da:	89 2b       	or	r24, r25
     6dc:	81 f4       	brne	.+32     	; 0x6fe <TRACK_Tick+0x192>
				sendValue += 7;
     6de:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     6e2:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     6e6:	07 96       	adiw	r24, 0x07	; 7
     6e8:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     6ec:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag7 = 1;
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <flag7+0x1>
     6f8:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <flag7>
     6fc:	fb c0       	rjmp	.+502    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[1][3] == 1 && flag8 == 0){
     6fe:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <data+0xe>
     702:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <data+0xf>
     706:	01 97       	sbiw	r24, 0x01	; 1
     708:	b1 f4       	brne	.+44     	; 0x736 <TRACK_Tick+0x1ca>
     70a:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <flag8>
     70e:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <flag8+0x1>
     712:	89 2b       	or	r24, r25
     714:	81 f4       	brne	.+32     	; 0x736 <TRACK_Tick+0x1ca>
				sendValue += 8;
     716:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     71a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     71e:	08 96       	adiw	r24, 0x08	; 8
     720:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     724:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag8 = 1;
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	90 93 a1 07 	sts	0x07A1, r25	; 0x8007a1 <flag8+0x1>
     730:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <flag8>
     734:	df c0       	rjmp	.+446    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[2][0] == 1 && flag9 == 0){
     736:	80 91 28 07 	lds	r24, 0x0728	; 0x800728 <data+0x10>
     73a:	90 91 29 07 	lds	r25, 0x0729	; 0x800729 <data+0x11>
     73e:	01 97       	sbiw	r24, 0x01	; 1
     740:	b1 f4       	brne	.+44     	; 0x76e <TRACK_Tick+0x202>
     742:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <flag9>
     746:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <flag9+0x1>
     74a:	89 2b       	or	r24, r25
     74c:	81 f4       	brne	.+32     	; 0x76e <TRACK_Tick+0x202>
				sendValue += 9;
     74e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     752:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     756:	09 96       	adiw	r24, 0x09	; 9
     758:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     75c:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag9 = 1;
     760:	81 e0       	ldi	r24, 0x01	; 1
     762:	90 e0       	ldi	r25, 0x00	; 0
     764:	90 93 a6 07 	sts	0x07A6, r25	; 0x8007a6 <flag9+0x1>
     768:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <flag9>
     76c:	c3 c0       	rjmp	.+390    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[2][1] == 1 && flag10 == 0){
     76e:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <data+0x12>
     772:	90 91 2b 07 	lds	r25, 0x072B	; 0x80072b <data+0x13>
     776:	01 97       	sbiw	r24, 0x01	; 1
     778:	b1 f4       	brne	.+44     	; 0x7a6 <TRACK_Tick+0x23a>
     77a:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <flag10>
     77e:	90 91 9b 07 	lds	r25, 0x079B	; 0x80079b <flag10+0x1>
     782:	89 2b       	or	r24, r25
     784:	81 f4       	brne	.+32     	; 0x7a6 <TRACK_Tick+0x23a>
				sendValue += 10;
     786:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     78a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     78e:	0a 96       	adiw	r24, 0x0a	; 10
     790:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     794:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag10 = 1;
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	90 93 9b 07 	sts	0x079B, r25	; 0x80079b <flag10+0x1>
     7a0:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <flag10>
     7a4:	a7 c0       	rjmp	.+334    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[2][2] == 1 && flag11 == 0){
     7a6:	80 91 2c 07 	lds	r24, 0x072C	; 0x80072c <data+0x14>
     7aa:	90 91 2d 07 	lds	r25, 0x072D	; 0x80072d <data+0x15>
     7ae:	01 97       	sbiw	r24, 0x01	; 1
     7b0:	b1 f4       	brne	.+44     	; 0x7de <TRACK_Tick+0x272>
     7b2:	80 91 b3 07 	lds	r24, 0x07B3	; 0x8007b3 <flag11>
     7b6:	90 91 b4 07 	lds	r25, 0x07B4	; 0x8007b4 <flag11+0x1>
     7ba:	89 2b       	or	r24, r25
     7bc:	81 f4       	brne	.+32     	; 0x7de <TRACK_Tick+0x272>
				sendValue += 11;
     7be:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     7c2:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     7c6:	0b 96       	adiw	r24, 0x0b	; 11
     7c8:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     7cc:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag11 = 1;
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	90 93 b4 07 	sts	0x07B4, r25	; 0x8007b4 <flag11+0x1>
     7d8:	80 93 b3 07 	sts	0x07B3, r24	; 0x8007b3 <flag11>
     7dc:	8b c0       	rjmp	.+278    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[2][3] == 1 && flag12 == 0){
     7de:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <data+0x16>
     7e2:	90 91 2f 07 	lds	r25, 0x072F	; 0x80072f <data+0x17>
     7e6:	01 97       	sbiw	r24, 0x01	; 1
     7e8:	b1 f4       	brne	.+44     	; 0x816 <TRACK_Tick+0x2aa>
     7ea:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <flag12>
     7ee:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <flag12+0x1>
     7f2:	89 2b       	or	r24, r25
     7f4:	81 f4       	brne	.+32     	; 0x816 <TRACK_Tick+0x2aa>
				sendValue += 12;
     7f6:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     7fa:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     7fe:	0c 96       	adiw	r24, 0x0c	; 12
     800:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     804:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag12 = 1;
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	90 93 aa 07 	sts	0x07AA, r25	; 0x8007aa <flag12+0x1>
     810:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <flag12>
     814:	6f c0       	rjmp	.+222    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[3][0] == 1 && flag13 == 0){
     816:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <data+0x18>
     81a:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <data+0x19>
     81e:	01 97       	sbiw	r24, 0x01	; 1
     820:	b1 f4       	brne	.+44     	; 0x84e <TRACK_Tick+0x2e2>
     822:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <flag13>
     826:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <flag13+0x1>
     82a:	89 2b       	or	r24, r25
     82c:	81 f4       	brne	.+32     	; 0x84e <TRACK_Tick+0x2e2>
				sendValue += 13;
     82e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     832:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     836:	0d 96       	adiw	r24, 0x0d	; 13
     838:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     83c:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag13 = 1;
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	90 93 95 07 	sts	0x0795, r25	; 0x800795 <flag13+0x1>
     848:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <flag13>
     84c:	53 c0       	rjmp	.+166    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[3][1] == 1 && flag14 == 0){
     84e:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <data+0x1a>
     852:	90 91 33 07 	lds	r25, 0x0733	; 0x800733 <data+0x1b>
     856:	01 97       	sbiw	r24, 0x01	; 1
     858:	b1 f4       	brne	.+44     	; 0x886 <TRACK_Tick+0x31a>
     85a:	80 91 b1 07 	lds	r24, 0x07B1	; 0x8007b1 <flag14>
     85e:	90 91 b2 07 	lds	r25, 0x07B2	; 0x8007b2 <flag14+0x1>
     862:	89 2b       	or	r24, r25
     864:	81 f4       	brne	.+32     	; 0x886 <TRACK_Tick+0x31a>
				sendValue += 14;
     866:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     86a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     86e:	0e 96       	adiw	r24, 0x0e	; 14
     870:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     874:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag14 = 1;
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	90 93 b2 07 	sts	0x07B2, r25	; 0x8007b2 <flag14+0x1>
     880:	80 93 b1 07 	sts	0x07B1, r24	; 0x8007b1 <flag14>
     884:	37 c0       	rjmp	.+110    	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[3][2] == 1 && flag15 == 0){
     886:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <data+0x1c>
     88a:	90 91 35 07 	lds	r25, 0x0735	; 0x800735 <data+0x1d>
     88e:	01 97       	sbiw	r24, 0x01	; 1
     890:	b1 f4       	brne	.+44     	; 0x8be <TRACK_Tick+0x352>
     892:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <flag15>
     896:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <flag15+0x1>
     89a:	89 2b       	or	r24, r25
     89c:	81 f4       	brne	.+32     	; 0x8be <TRACK_Tick+0x352>
				sendValue += 15;
     89e:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     8a2:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     8a6:	0f 96       	adiw	r24, 0x0f	; 15
     8a8:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     8ac:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag15 = 1;
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	90 93 a8 07 	sts	0x07A8, r25	; 0x8007a8 <flag15+0x1>
     8b8:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <flag15>
     8bc:	1b c0       	rjmp	.+54     	; 0x8f4 <TRACK_Tick+0x388>
			}
			else if(data[3][3] == 1 && flag16 == 0){
     8be:	80 91 36 07 	lds	r24, 0x0736	; 0x800736 <data+0x1e>
     8c2:	90 91 37 07 	lds	r25, 0x0737	; 0x800737 <data+0x1f>
     8c6:	01 97       	sbiw	r24, 0x01	; 1
     8c8:	a9 f4       	brne	.+42     	; 0x8f4 <TRACK_Tick+0x388>
     8ca:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <flag16>
     8ce:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <flag16+0x1>
     8d2:	89 2b       	or	r24, r25
     8d4:	79 f4       	brne	.+30     	; 0x8f4 <TRACK_Tick+0x388>
				sendValue += 16;
     8d6:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     8da:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <sendValue+0x1>
     8de:	40 96       	adiw	r24, 0x10	; 16
     8e0:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <sendValue+0x1>
     8e4:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <sendValue>
				flag16 = 1;
     8e8:	81 e0       	ldi	r24, 0x01	; 1
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	90 93 13 07 	sts	0x0713, r25	; 0x800713 <flag16+0x1>
     8f0:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <flag16>
			}
			
			//actually send "sendValue" here
			if( USART_IsSendReady(0))
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	c3 dc       	rcall	.-1658   	; 0x280 <USART_IsSendReady>
     8fa:	88 23       	and	r24, r24
     8fc:	31 f0       	breq	.+12     	; 0x90a <TRACK_Tick+0x39e>
			{
				USART_Send(sendValue);
     8fe:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <sendValue>
     902:	d1 dc       	rcall	.-1630   	; 0x2a6 <USART_Send>
				USART_Flush(0);
     904:	80 e0       	ldi	r24, 0x00	; 0
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	bf dc       	rcall	.-1666   	; 0x288 <USART_Flush>
			
			break;
		case wait:  // wait for new data change
			break;
	}
	switch(trackData){
     90a:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <trackData>
     90e:	88 23       	and	r24, r24
     910:	19 f0       	breq	.+6      	; 0x918 <TRACK_Tick+0x3ac>
     912:	81 30       	cpi	r24, 0x01	; 1
     914:	41 f4       	brne	.+16     	; 0x926 <TRACK_Tick+0x3ba>
     916:	04 c0       	rjmp	.+8      	; 0x920 <TRACK_Tick+0x3b4>
		case INITTrack:
			trackData = send;
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <trackData>
			break;
     91e:	08 95       	ret
		case send:
			trackData = wait;
     920:	82 e0       	ldi	r24, 0x02	; 2
     922:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <trackData>
     926:	08 95       	ret

00000928 <TrackSecTask>:
void MOVE_Init(){
	moveMouse = INIT;
}

void TRACK_Init(){
	trackData = INITTrack;
     928:	10 92 a2 07 	sts	0x07A2, r1	; 0x8007a2 <trackData>
}

void TrackSecTask(){
	TRACK_Init();
	for(;;){
		TRACK_Tick();
     92c:	1f de       	rcall	.-962    	; 0x56c <TRACK_Tick>
		vTaskDelay(100);	
     92e:	84 e6       	ldi	r24, 0x64	; 100
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	53 d4       	rcall	.+2214   	; 0x11da <vTaskDelay>
	}
     934:	fb cf       	rjmp	.-10     	; 0x92c <TrackSecTask+0x4>

00000936 <EMIT_Tick>:
	}	
}


void EMIT_Tick(){
	switch(emitLight){
     936:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <emitLight>
     93a:	81 30       	cpi	r24, 0x01	; 1
     93c:	41 f0       	breq	.+16     	; 0x94e <EMIT_Tick+0x18>
     93e:	18 f0       	brcs	.+6      	; 0x946 <EMIT_Tick+0x10>
     940:	82 30       	cpi	r24, 0x02	; 2
     942:	61 f0       	breq	.+24     	; 0x95c <EMIT_Tick+0x26>
     944:	08 95       	ret
		case INITEmit:
			emitLight = on;
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <emitLight>
			break;
     94c:	08 95       	ret
		case on:
			PORTA = (PORTA & 0x8F) | 0x70;
     94e:	82 b1       	in	r24, 0x02	; 2
     950:	80 67       	ori	r24, 0x70	; 112
     952:	82 b9       	out	0x02, r24	; 2
			emitLight = on;
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <emitLight>
			break;
     95a:	08 95       	ret
		case off:
			PORTA  = (PORTA & 0x8F) | 0x00;
     95c:	82 b1       	in	r24, 0x02	; 2
     95e:	8f 78       	andi	r24, 0x8F	; 143
     960:	82 b9       	out	0x02, r24	; 2
			emitLight = on;
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <emitLight>
     968:	08 95       	ret

0000096a <EmitSecTask>:
void TRACK_Init(){
	trackData = INITTrack;
}

void EMIT_Init(){
	emitLight = INITEmit;
     96a:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <emitLight>
}

void EmitSecTask(){
	EMIT_Init();
	for(;;){
		EMIT_Tick();
     96e:	e3 df       	rcall	.-58     	; 0x936 <EMIT_Tick>
		vTaskDelay(100);
     970:	84 e6       	ldi	r24, 0x64	; 100
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	32 d4       	rcall	.+2148   	; 0x11da <vTaskDelay>
	}
     976:	fb cf       	rjmp	.-10     	; 0x96e <EmitSecTask+0x4>

00000978 <StartSecPulse>:
		vTaskDelay(100);	
	}
}

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
     978:	af 92       	push	r10
     97a:	bf 92       	push	r11
     97c:	cf 92       	push	r12
     97e:	df 92       	push	r13
     980:	ef 92       	push	r14
     982:	ff 92       	push	r15
     984:	0f 93       	push	r16
     986:	cf 93       	push	r28
	xTaskCreate(MoveSecTask, (signed portCHAR *)"MoveSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     988:	a1 2c       	mov	r10, r1
     98a:	b1 2c       	mov	r11, r1
     98c:	c1 2c       	mov	r12, r1
     98e:	d1 2c       	mov	r13, r1
     990:	e1 2c       	mov	r14, r1
     992:	f1 2c       	mov	r15, r1
     994:	08 2f       	mov	r16, r24
     996:	20 e0       	ldi	r18, 0x00	; 0
     998:	30 e0       	ldi	r19, 0x00	; 0
     99a:	45 e5       	ldi	r20, 0x55	; 85
     99c:	50 e0       	ldi	r21, 0x00	; 0
     99e:	68 e0       	ldi	r22, 0x08	; 8
     9a0:	71 e0       	ldi	r23, 0x01	; 1
     9a2:	8f ea       	ldi	r24, 0xAF	; 175
     9a4:	92 e0       	ldi	r25, 0x02	; 2
     9a6:	b5 d1       	rcall	.+874    	; 0xd12 <xTaskGenericCreate>
	xTaskCreate(TrackSecTask, (signed portCHAR *)"TrackSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     9a8:	20 e0       	ldi	r18, 0x00	; 0
     9aa:	30 e0       	ldi	r19, 0x00	; 0
     9ac:	45 e5       	ldi	r20, 0x55	; 85
     9ae:	50 e0       	ldi	r21, 0x00	; 0
     9b0:	64 e1       	ldi	r22, 0x14	; 20
     9b2:	71 e0       	ldi	r23, 0x01	; 1
     9b4:	84 e9       	ldi	r24, 0x94	; 148
     9b6:	94 e0       	ldi	r25, 0x04	; 4
     9b8:	ac d1       	rcall	.+856    	; 0xd12 <xTaskGenericCreate>
	xTaskCreate(EmitSecTask, (signed portCHAR *)"EmitSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     9ba:	20 e0       	ldi	r18, 0x00	; 0
     9bc:	30 e0       	ldi	r19, 0x00	; 0
     9be:	45 e5       	ldi	r20, 0x55	; 85
     9c0:	50 e0       	ldi	r21, 0x00	; 0
     9c2:	61 e2       	ldi	r22, 0x21	; 33
     9c4:	71 e0       	ldi	r23, 0x01	; 1
     9c6:	85 eb       	ldi	r24, 0xB5	; 181
     9c8:	94 e0       	ldi	r25, 0x04	; 4
     9ca:	a3 d1       	rcall	.+838    	; 0xd12 <xTaskGenericCreate>
}	
     9cc:	cf 91       	pop	r28
     9ce:	0f 91       	pop	r16
     9d0:	ff 90       	pop	r15
     9d2:	ef 90       	pop	r14
     9d4:	df 90       	pop	r13
     9d6:	cf 90       	pop	r12
     9d8:	bf 90       	pop	r11
     9da:	af 90       	pop	r10
     9dc:	08 95       	ret

000009de <main>:
 
int main(void) 
{ 
   DDRA = 0xF0; PORTA=0xFF;
     9de:	80 ef       	ldi	r24, 0xF0	; 240
     9e0:	81 b9       	out	0x01, r24	; 1
     9e2:	8f ef       	ldi	r24, 0xFF	; 255
     9e4:	82 b9       	out	0x02, r24	; 2
   DDRC = 0xFF; 
     9e6:	87 b9       	out	0x07, r24	; 7
   DDRD = 0xFF;
     9e8:	8a b9       	out	0x0a, r24	; 10
   //Start Tasks  
   StartSecPulse(1);
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	c5 df       	rcall	.-118    	; 0x978 <StartSecPulse>
    //RunSchedular 
   vTaskStartScheduler(); 
     9ee:	84 d2       	rcall	.+1288   	; 0xef8 <vTaskStartScheduler>
 
   return 0; 
     9f0:	80 e0       	ldi	r24, 0x00	; 0
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	08 95       	ret

000009f6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     9f6:	31 e1       	ldi	r19, 0x11	; 17
     9f8:	fc 01       	movw	r30, r24
     9fa:	30 83       	st	Z, r19
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	22 e2       	ldi	r18, 0x22	; 34
     a00:	20 83       	st	Z, r18
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	a3 e3       	ldi	r26, 0x33	; 51
     a06:	a0 83       	st	Z, r26
     a08:	31 97       	sbiw	r30, 0x01	; 1
     a0a:	60 83       	st	Z, r22
     a0c:	31 97       	sbiw	r30, 0x01	; 1
     a0e:	70 83       	st	Z, r23
     a10:	31 97       	sbiw	r30, 0x01	; 1
     a12:	10 82       	st	Z, r1
     a14:	31 97       	sbiw	r30, 0x01	; 1
     a16:	60 e8       	ldi	r22, 0x80	; 128
     a18:	60 83       	st	Z, r22
     a1a:	31 97       	sbiw	r30, 0x01	; 1
     a1c:	10 82       	st	Z, r1
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	62 e0       	ldi	r22, 0x02	; 2
     a22:	60 83       	st	Z, r22
     a24:	31 97       	sbiw	r30, 0x01	; 1
     a26:	63 e0       	ldi	r22, 0x03	; 3
     a28:	60 83       	st	Z, r22
     a2a:	31 97       	sbiw	r30, 0x01	; 1
     a2c:	64 e0       	ldi	r22, 0x04	; 4
     a2e:	60 83       	st	Z, r22
     a30:	31 97       	sbiw	r30, 0x01	; 1
     a32:	65 e0       	ldi	r22, 0x05	; 5
     a34:	60 83       	st	Z, r22
     a36:	31 97       	sbiw	r30, 0x01	; 1
     a38:	66 e0       	ldi	r22, 0x06	; 6
     a3a:	60 83       	st	Z, r22
     a3c:	31 97       	sbiw	r30, 0x01	; 1
     a3e:	67 e0       	ldi	r22, 0x07	; 7
     a40:	60 83       	st	Z, r22
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	68 e0       	ldi	r22, 0x08	; 8
     a46:	60 83       	st	Z, r22
     a48:	31 97       	sbiw	r30, 0x01	; 1
     a4a:	69 e0       	ldi	r22, 0x09	; 9
     a4c:	60 83       	st	Z, r22
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	60 e1       	ldi	r22, 0x10	; 16
     a52:	60 83       	st	Z, r22
     a54:	31 97       	sbiw	r30, 0x01	; 1
     a56:	30 83       	st	Z, r19
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	32 e1       	ldi	r19, 0x12	; 18
     a5c:	30 83       	st	Z, r19
     a5e:	31 97       	sbiw	r30, 0x01	; 1
     a60:	33 e1       	ldi	r19, 0x13	; 19
     a62:	30 83       	st	Z, r19
     a64:	31 97       	sbiw	r30, 0x01	; 1
     a66:	34 e1       	ldi	r19, 0x14	; 20
     a68:	30 83       	st	Z, r19
     a6a:	31 97       	sbiw	r30, 0x01	; 1
     a6c:	35 e1       	ldi	r19, 0x15	; 21
     a6e:	30 83       	st	Z, r19
     a70:	31 97       	sbiw	r30, 0x01	; 1
     a72:	36 e1       	ldi	r19, 0x16	; 22
     a74:	30 83       	st	Z, r19
     a76:	31 97       	sbiw	r30, 0x01	; 1
     a78:	37 e1       	ldi	r19, 0x17	; 23
     a7a:	30 83       	st	Z, r19
     a7c:	31 97       	sbiw	r30, 0x01	; 1
     a7e:	38 e1       	ldi	r19, 0x18	; 24
     a80:	30 83       	st	Z, r19
     a82:	31 97       	sbiw	r30, 0x01	; 1
     a84:	39 e1       	ldi	r19, 0x19	; 25
     a86:	30 83       	st	Z, r19
     a88:	31 97       	sbiw	r30, 0x01	; 1
     a8a:	30 e2       	ldi	r19, 0x20	; 32
     a8c:	30 83       	st	Z, r19
     a8e:	31 97       	sbiw	r30, 0x01	; 1
     a90:	31 e2       	ldi	r19, 0x21	; 33
     a92:	30 83       	st	Z, r19
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	20 83       	st	Z, r18
     a98:	31 97       	sbiw	r30, 0x01	; 1
     a9a:	23 e2       	ldi	r18, 0x23	; 35
     a9c:	20 83       	st	Z, r18
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	40 83       	st	Z, r20
     aa2:	31 97       	sbiw	r30, 0x01	; 1
     aa4:	50 83       	st	Z, r21
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	26 e2       	ldi	r18, 0x26	; 38
     aaa:	20 83       	st	Z, r18
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	27 e2       	ldi	r18, 0x27	; 39
     ab0:	20 83       	st	Z, r18
     ab2:	31 97       	sbiw	r30, 0x01	; 1
     ab4:	28 e2       	ldi	r18, 0x28	; 40
     ab6:	20 83       	st	Z, r18
     ab8:	31 97       	sbiw	r30, 0x01	; 1
     aba:	29 e2       	ldi	r18, 0x29	; 41
     abc:	20 83       	st	Z, r18
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	20 e3       	ldi	r18, 0x30	; 48
     ac2:	20 83       	st	Z, r18
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	21 e3       	ldi	r18, 0x31	; 49
     ac8:	20 83       	st	Z, r18
     aca:	86 97       	sbiw	r24, 0x26	; 38
     acc:	08 95       	ret

00000ace <xPortStartScheduler>:
     ace:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     ad2:	8c e7       	ldi	r24, 0x7C	; 124
     ad4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     ad8:	8b e0       	ldi	r24, 0x0B	; 11
     ada:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     ade:	ef e6       	ldi	r30, 0x6F	; 111
     ae0:	f0 e0       	ldi	r31, 0x00	; 0
     ae2:	80 81       	ld	r24, Z
     ae4:	82 60       	ori	r24, 0x02	; 2
     ae6:	80 83       	st	Z, r24
     ae8:	a0 91 90 07 	lds	r26, 0x0790	; 0x800790 <pxCurrentTCB>
     aec:	b0 91 91 07 	lds	r27, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     af0:	cd 91       	ld	r28, X+
     af2:	cd bf       	out	0x3d, r28	; 61
     af4:	dd 91       	ld	r29, X+
     af6:	de bf       	out	0x3e, r29	; 62
     af8:	ff 91       	pop	r31
     afa:	ef 91       	pop	r30
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	bf 91       	pop	r27
     b02:	af 91       	pop	r26
     b04:	9f 91       	pop	r25
     b06:	8f 91       	pop	r24
     b08:	7f 91       	pop	r23
     b0a:	6f 91       	pop	r22
     b0c:	5f 91       	pop	r21
     b0e:	4f 91       	pop	r20
     b10:	3f 91       	pop	r19
     b12:	2f 91       	pop	r18
     b14:	1f 91       	pop	r17
     b16:	0f 91       	pop	r16
     b18:	ff 90       	pop	r15
     b1a:	ef 90       	pop	r14
     b1c:	df 90       	pop	r13
     b1e:	cf 90       	pop	r12
     b20:	bf 90       	pop	r11
     b22:	af 90       	pop	r10
     b24:	9f 90       	pop	r9
     b26:	8f 90       	pop	r8
     b28:	7f 90       	pop	r7
     b2a:	6f 90       	pop	r6
     b2c:	5f 90       	pop	r5
     b2e:	4f 90       	pop	r4
     b30:	3f 90       	pop	r3
     b32:	2f 90       	pop	r2
     b34:	1f 90       	pop	r1
     b36:	0f 90       	pop	r0
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	0f 90       	pop	r0
     b3c:	08 95       	ret
     b3e:	81 e0       	ldi	r24, 0x01	; 1
     b40:	08 95       	ret

00000b42 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b42:	0f 92       	push	r0
     b44:	0f b6       	in	r0, 0x3f	; 63
     b46:	f8 94       	cli
     b48:	0f 92       	push	r0
     b4a:	1f 92       	push	r1
     b4c:	11 24       	eor	r1, r1
     b4e:	2f 92       	push	r2
     b50:	3f 92       	push	r3
     b52:	4f 92       	push	r4
     b54:	5f 92       	push	r5
     b56:	6f 92       	push	r6
     b58:	7f 92       	push	r7
     b5a:	8f 92       	push	r8
     b5c:	9f 92       	push	r9
     b5e:	af 92       	push	r10
     b60:	bf 92       	push	r11
     b62:	cf 92       	push	r12
     b64:	df 92       	push	r13
     b66:	ef 92       	push	r14
     b68:	ff 92       	push	r15
     b6a:	0f 93       	push	r16
     b6c:	1f 93       	push	r17
     b6e:	2f 93       	push	r18
     b70:	3f 93       	push	r19
     b72:	4f 93       	push	r20
     b74:	5f 93       	push	r21
     b76:	6f 93       	push	r22
     b78:	7f 93       	push	r23
     b7a:	8f 93       	push	r24
     b7c:	9f 93       	push	r25
     b7e:	af 93       	push	r26
     b80:	bf 93       	push	r27
     b82:	cf 93       	push	r28
     b84:	df 93       	push	r29
     b86:	ef 93       	push	r30
     b88:	ff 93       	push	r31
     b8a:	a0 91 90 07 	lds	r26, 0x0790	; 0x800790 <pxCurrentTCB>
     b8e:	b0 91 91 07 	lds	r27, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     b92:	0d b6       	in	r0, 0x3d	; 61
     b94:	0d 92       	st	X+, r0
     b96:	0e b6       	in	r0, 0x3e	; 62
     b98:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b9a:	73 d3       	rcall	.+1766   	; 0x1282 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b9c:	a0 91 90 07 	lds	r26, 0x0790	; 0x800790 <pxCurrentTCB>
     ba0:	b0 91 91 07 	lds	r27, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     ba4:	cd 91       	ld	r28, X+
     ba6:	cd bf       	out	0x3d, r28	; 61
     ba8:	dd 91       	ld	r29, X+
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	ff 91       	pop	r31
     bae:	ef 91       	pop	r30
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	bf 91       	pop	r27
     bb6:	af 91       	pop	r26
     bb8:	9f 91       	pop	r25
     bba:	8f 91       	pop	r24
     bbc:	7f 91       	pop	r23
     bbe:	6f 91       	pop	r22
     bc0:	5f 91       	pop	r21
     bc2:	4f 91       	pop	r20
     bc4:	3f 91       	pop	r19
     bc6:	2f 91       	pop	r18
     bc8:	1f 91       	pop	r17
     bca:	0f 91       	pop	r16
     bcc:	ff 90       	pop	r15
     bce:	ef 90       	pop	r14
     bd0:	df 90       	pop	r13
     bd2:	cf 90       	pop	r12
     bd4:	bf 90       	pop	r11
     bd6:	af 90       	pop	r10
     bd8:	9f 90       	pop	r9
     bda:	8f 90       	pop	r8
     bdc:	7f 90       	pop	r7
     bde:	6f 90       	pop	r6
     be0:	5f 90       	pop	r5
     be2:	4f 90       	pop	r4
     be4:	3f 90       	pop	r3
     be6:	2f 90       	pop	r2
     be8:	1f 90       	pop	r1
     bea:	0f 90       	pop	r0
     bec:	0f be       	out	0x3f, r0	; 63
     bee:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bf0:	08 95       	ret

00000bf2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     bf2:	0f 92       	push	r0
     bf4:	0f b6       	in	r0, 0x3f	; 63
     bf6:	f8 94       	cli
     bf8:	0f 92       	push	r0
     bfa:	1f 92       	push	r1
     bfc:	11 24       	eor	r1, r1
     bfe:	2f 92       	push	r2
     c00:	3f 92       	push	r3
     c02:	4f 92       	push	r4
     c04:	5f 92       	push	r5
     c06:	6f 92       	push	r6
     c08:	7f 92       	push	r7
     c0a:	8f 92       	push	r8
     c0c:	9f 92       	push	r9
     c0e:	af 92       	push	r10
     c10:	bf 92       	push	r11
     c12:	cf 92       	push	r12
     c14:	df 92       	push	r13
     c16:	ef 92       	push	r14
     c18:	ff 92       	push	r15
     c1a:	0f 93       	push	r16
     c1c:	1f 93       	push	r17
     c1e:	2f 93       	push	r18
     c20:	3f 93       	push	r19
     c22:	4f 93       	push	r20
     c24:	5f 93       	push	r21
     c26:	6f 93       	push	r22
     c28:	7f 93       	push	r23
     c2a:	8f 93       	push	r24
     c2c:	9f 93       	push	r25
     c2e:	af 93       	push	r26
     c30:	bf 93       	push	r27
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	ef 93       	push	r30
     c38:	ff 93       	push	r31
     c3a:	a0 91 90 07 	lds	r26, 0x0790	; 0x800790 <pxCurrentTCB>
     c3e:	b0 91 91 07 	lds	r27, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     c42:	0d b6       	in	r0, 0x3d	; 61
     c44:	0d 92       	st	X+, r0
     c46:	0e b6       	in	r0, 0x3e	; 62
     c48:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     c4a:	85 d1       	rcall	.+778    	; 0xf56 <vTaskIncrementTick>
	vTaskSwitchContext();
     c4c:	1a d3       	rcall	.+1588   	; 0x1282 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c4e:	a0 91 90 07 	lds	r26, 0x0790	; 0x800790 <pxCurrentTCB>
     c52:	b0 91 91 07 	lds	r27, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     c56:	cd 91       	ld	r28, X+
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	dd 91       	ld	r29, X+
     c5c:	de bf       	out	0x3e, r29	; 62
     c5e:	ff 91       	pop	r31
     c60:	ef 91       	pop	r30
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	bf 91       	pop	r27
     c68:	af 91       	pop	r26
     c6a:	9f 91       	pop	r25
     c6c:	8f 91       	pop	r24
     c6e:	7f 91       	pop	r23
     c70:	6f 91       	pop	r22
     c72:	5f 91       	pop	r21
     c74:	4f 91       	pop	r20
     c76:	3f 91       	pop	r19
     c78:	2f 91       	pop	r18
     c7a:	1f 91       	pop	r17
     c7c:	0f 91       	pop	r16
     c7e:	ff 90       	pop	r15
     c80:	ef 90       	pop	r14
     c82:	df 90       	pop	r13
     c84:	cf 90       	pop	r12
     c86:	bf 90       	pop	r11
     c88:	af 90       	pop	r10
     c8a:	9f 90       	pop	r9
     c8c:	8f 90       	pop	r8
     c8e:	7f 90       	pop	r7
     c90:	6f 90       	pop	r6
     c92:	5f 90       	pop	r5
     c94:	4f 90       	pop	r4
     c96:	3f 90       	pop	r3
     c98:	2f 90       	pop	r2
     c9a:	1f 90       	pop	r1
     c9c:	0f 90       	pop	r0
     c9e:	0f be       	out	0x3f, r0	; 63
     ca0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ca2:	08 95       	ret

00000ca4 <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     ca4:	a6 df       	rcall	.-180    	; 0xbf2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     ca6:	18 95       	reti

00000ca8 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29
     cac:	ec 01       	movw	r28, r24
     cae:	e0 91 90 07 	lds	r30, 0x0790	; 0x800790 <pxCurrentTCB>
     cb2:	f0 91 91 07 	lds	r31, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     cb6:	93 83       	std	Z+3, r25	; 0x03
     cb8:	82 83       	std	Z+2, r24	; 0x02
     cba:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <xTickCount>
     cbe:	90 91 41 07 	lds	r25, 0x0741	; 0x800741 <xTickCount+0x1>
     cc2:	c8 17       	cp	r28, r24
     cc4:	d9 07       	cpc	r29, r25
     cc6:	60 f4       	brcc	.+24     	; 0xce0 <prvAddCurrentTaskToDelayedList+0x38>
     cc8:	60 91 90 07 	lds	r22, 0x0790	; 0x800790 <pxCurrentTCB>
     ccc:	70 91 91 07 	lds	r23, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     cd0:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <pxOverflowDelayedTaskList>
     cd4:	90 91 57 07 	lds	r25, 0x0757	; 0x800757 <pxOverflowDelayedTaskList+0x1>
     cd8:	6e 5f       	subi	r22, 0xFE	; 254
     cda:	7f 4f       	sbci	r23, 0xFF	; 255
     cdc:	70 da       	rcall	.-2848   	; 0x1be <vListInsert>
     cde:	16 c0       	rjmp	.+44     	; 0xd0c <prvAddCurrentTaskToDelayedList+0x64>
     ce0:	60 91 90 07 	lds	r22, 0x0790	; 0x800790 <pxCurrentTCB>
     ce4:	70 91 91 07 	lds	r23, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     ce8:	80 91 58 07 	lds	r24, 0x0758	; 0x800758 <pxDelayedTaskList>
     cec:	90 91 59 07 	lds	r25, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
     cf0:	6e 5f       	subi	r22, 0xFE	; 254
     cf2:	7f 4f       	sbci	r23, 0xFF	; 255
     cf4:	64 da       	rcall	.-2872   	; 0x1be <vListInsert>
     cf6:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <xNextTaskUnblockTime>
     cfa:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <xNextTaskUnblockTime+0x1>
     cfe:	c8 17       	cp	r28, r24
     d00:	d9 07       	cpc	r29, r25
     d02:	20 f4       	brcc	.+8      	; 0xd0c <prvAddCurrentTaskToDelayedList+0x64>
     d04:	d0 93 07 01 	sts	0x0107, r29	; 0x800107 <xNextTaskUnblockTime+0x1>
     d08:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <xNextTaskUnblockTime>
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	08 95       	ret

00000d12 <xTaskGenericCreate>:
     d12:	4f 92       	push	r4
     d14:	5f 92       	push	r5
     d16:	6f 92       	push	r6
     d18:	7f 92       	push	r7
     d1a:	8f 92       	push	r8
     d1c:	9f 92       	push	r9
     d1e:	af 92       	push	r10
     d20:	bf 92       	push	r11
     d22:	cf 92       	push	r12
     d24:	df 92       	push	r13
     d26:	ef 92       	push	r14
     d28:	ff 92       	push	r15
     d2a:	0f 93       	push	r16
     d2c:	1f 93       	push	r17
     d2e:	cf 93       	push	r28
     d30:	df 93       	push	r29
     d32:	5c 01       	movw	r10, r24
     d34:	4b 01       	movw	r8, r22
     d36:	3a 01       	movw	r6, r20
     d38:	29 01       	movw	r4, r18
     d3a:	81 e2       	ldi	r24, 0x21	; 33
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	e1 d9       	rcall	.-3134   	; 0x102 <pvPortMalloc>
     d40:	ec 01       	movw	r28, r24
     d42:	89 2b       	or	r24, r25
     d44:	09 f4       	brne	.+2      	; 0xd48 <xTaskGenericCreate+0x36>
     d46:	c6 c0       	rjmp	.+396    	; 0xed4 <xTaskGenericCreate+0x1c2>
     d48:	c1 14       	cp	r12, r1
     d4a:	d1 04       	cpc	r13, r1
     d4c:	09 f0       	breq	.+2      	; 0xd50 <xTaskGenericCreate+0x3e>
     d4e:	be c0       	rjmp	.+380    	; 0xecc <xTaskGenericCreate+0x1ba>
     d50:	c3 01       	movw	r24, r6
     d52:	d7 d9       	rcall	.-3154   	; 0x102 <pvPortMalloc>
     d54:	98 8f       	std	Y+24, r25	; 0x18
     d56:	8f 8b       	std	Y+23, r24	; 0x17
     d58:	00 97       	sbiw	r24, 0x00	; 0
     d5a:	19 f4       	brne	.+6      	; 0xd62 <xTaskGenericCreate+0x50>
     d5c:	ce 01       	movw	r24, r28
     d5e:	f5 d9       	rcall	.-3094   	; 0x14a <vPortFree>
     d60:	b9 c0       	rjmp	.+370    	; 0xed4 <xTaskGenericCreate+0x1c2>
     d62:	a3 01       	movw	r20, r6
     d64:	65 ea       	ldi	r22, 0xA5	; 165
     d66:	70 e0       	ldi	r23, 0x00	; 0
     d68:	56 d3       	rcall	.+1708   	; 0x1416 <memset>
     d6a:	93 01       	movw	r18, r6
     d6c:	21 50       	subi	r18, 0x01	; 1
     d6e:	31 09       	sbc	r19, r1
     d70:	8f 89       	ldd	r24, Y+23	; 0x17
     d72:	98 8d       	ldd	r25, Y+24	; 0x18
     d74:	3c 01       	movw	r6, r24
     d76:	62 0e       	add	r6, r18
     d78:	73 1e       	adc	r7, r19
     d7a:	48 e0       	ldi	r20, 0x08	; 8
     d7c:	50 e0       	ldi	r21, 0x00	; 0
     d7e:	b4 01       	movw	r22, r8
     d80:	ce 01       	movw	r24, r28
     d82:	49 96       	adiw	r24, 0x19	; 25
     d84:	4f d3       	rcall	.+1694   	; 0x1424 <strncpy>
     d86:	18 a2       	std	Y+32, r1	; 0x20
     d88:	10 2f       	mov	r17, r16
     d8a:	04 30       	cpi	r16, 0x04	; 4
     d8c:	08 f0       	brcs	.+2      	; 0xd90 <xTaskGenericCreate+0x7e>
     d8e:	13 e0       	ldi	r17, 0x03	; 3
     d90:	1e 8b       	std	Y+22, r17	; 0x16
     d92:	6e 01       	movw	r12, r28
     d94:	82 e0       	ldi	r24, 0x02	; 2
     d96:	c8 0e       	add	r12, r24
     d98:	d1 1c       	adc	r13, r1
     d9a:	c6 01       	movw	r24, r12
     d9c:	e5 d9       	rcall	.-3126   	; 0x168 <vListInitialiseItem>
     d9e:	ce 01       	movw	r24, r28
     da0:	0c 96       	adiw	r24, 0x0c	; 12
     da2:	e2 d9       	rcall	.-3132   	; 0x168 <vListInitialiseItem>
     da4:	d9 87       	std	Y+9, r29	; 0x09
     da6:	c8 87       	std	Y+8, r28	; 0x08
     da8:	84 e0       	ldi	r24, 0x04	; 4
     daa:	90 e0       	ldi	r25, 0x00	; 0
     dac:	81 1b       	sub	r24, r17
     dae:	91 09       	sbc	r25, r1
     db0:	9d 87       	std	Y+13, r25	; 0x0d
     db2:	8c 87       	std	Y+12, r24	; 0x0c
     db4:	db 8b       	std	Y+19, r29	; 0x13
     db6:	ca 8b       	std	Y+18, r28	; 0x12
     db8:	a2 01       	movw	r20, r4
     dba:	b5 01       	movw	r22, r10
     dbc:	c3 01       	movw	r24, r6
     dbe:	1b de       	rcall	.-970    	; 0x9f6 <pxPortInitialiseStack>
     dc0:	99 83       	std	Y+1, r25	; 0x01
     dc2:	88 83       	st	Y, r24
     dc4:	e1 14       	cp	r14, r1
     dc6:	f1 04       	cpc	r15, r1
     dc8:	19 f0       	breq	.+6      	; 0xdd0 <xTaskGenericCreate+0xbe>
     dca:	f7 01       	movw	r30, r14
     dcc:	d1 83       	std	Z+1, r29	; 0x01
     dce:	c0 83       	st	Z, r28
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	0f 92       	push	r0
     dd6:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <uxCurrentNumberOfTasks>
     dda:	8f 5f       	subi	r24, 0xFF	; 255
     ddc:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <uxCurrentNumberOfTasks>
     de0:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <pxCurrentTCB>
     de4:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     de8:	89 2b       	or	r24, r25
     dea:	69 f5       	brne	.+90     	; 0xe46 <xTaskGenericCreate+0x134>
     dec:	d0 93 91 07 	sts	0x0791, r29	; 0x800791 <pxCurrentTCB+0x1>
     df0:	c0 93 90 07 	sts	0x0790, r28	; 0x800790 <pxCurrentTCB>
     df4:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <uxCurrentNumberOfTasks>
     df8:	81 30       	cpi	r24, 0x01	; 1
     dfa:	a1 f5       	brne	.+104    	; 0xe64 <xTaskGenericCreate+0x152>
     dfc:	8c e6       	ldi	r24, 0x6C	; 108
     dfe:	97 e0       	ldi	r25, 0x07	; 7
     e00:	a5 d9       	rcall	.-3254   	; 0x14c <vListInitialise>
     e02:	85 e7       	ldi	r24, 0x75	; 117
     e04:	97 e0       	ldi	r25, 0x07	; 7
     e06:	a2 d9       	rcall	.-3260   	; 0x14c <vListInitialise>
     e08:	8e e7       	ldi	r24, 0x7E	; 126
     e0a:	97 e0       	ldi	r25, 0x07	; 7
     e0c:	9f d9       	rcall	.-3266   	; 0x14c <vListInitialise>
     e0e:	87 e8       	ldi	r24, 0x87	; 135
     e10:	97 e0       	ldi	r25, 0x07	; 7
     e12:	9c d9       	rcall	.-3272   	; 0x14c <vListInitialise>
     e14:	83 e6       	ldi	r24, 0x63	; 99
     e16:	97 e0       	ldi	r25, 0x07	; 7
     e18:	99 d9       	rcall	.-3278   	; 0x14c <vListInitialise>
     e1a:	8a e5       	ldi	r24, 0x5A	; 90
     e1c:	97 e0       	ldi	r25, 0x07	; 7
     e1e:	96 d9       	rcall	.-3284   	; 0x14c <vListInitialise>
     e20:	8d e4       	ldi	r24, 0x4D	; 77
     e22:	97 e0       	ldi	r25, 0x07	; 7
     e24:	93 d9       	rcall	.-3290   	; 0x14c <vListInitialise>
     e26:	84 e4       	ldi	r24, 0x44	; 68
     e28:	97 e0       	ldi	r25, 0x07	; 7
     e2a:	90 d9       	rcall	.-3296   	; 0x14c <vListInitialise>
     e2c:	83 e6       	ldi	r24, 0x63	; 99
     e2e:	97 e0       	ldi	r25, 0x07	; 7
     e30:	90 93 59 07 	sts	0x0759, r25	; 0x800759 <pxDelayedTaskList+0x1>
     e34:	80 93 58 07 	sts	0x0758, r24	; 0x800758 <pxDelayedTaskList>
     e38:	8a e5       	ldi	r24, 0x5A	; 90
     e3a:	97 e0       	ldi	r25, 0x07	; 7
     e3c:	90 93 57 07 	sts	0x0757, r25	; 0x800757 <pxOverflowDelayedTaskList+0x1>
     e40:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <pxOverflowDelayedTaskList>
     e44:	0f c0       	rjmp	.+30     	; 0xe64 <xTaskGenericCreate+0x152>
     e46:	80 91 3d 07 	lds	r24, 0x073D	; 0x80073d <xSchedulerRunning>
     e4a:	81 11       	cpse	r24, r1
     e4c:	0b c0       	rjmp	.+22     	; 0xe64 <xTaskGenericCreate+0x152>
     e4e:	e0 91 90 07 	lds	r30, 0x0790	; 0x800790 <pxCurrentTCB>
     e52:	f0 91 91 07 	lds	r31, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     e56:	86 89       	ldd	r24, Z+22	; 0x16
     e58:	08 17       	cp	r16, r24
     e5a:	20 f0       	brcs	.+8      	; 0xe64 <xTaskGenericCreate+0x152>
     e5c:	d0 93 91 07 	sts	0x0791, r29	; 0x800791 <pxCurrentTCB+0x1>
     e60:	c0 93 90 07 	sts	0x0790, r28	; 0x800790 <pxCurrentTCB>
     e64:	8e 89       	ldd	r24, Y+22	; 0x16
     e66:	90 91 3f 07 	lds	r25, 0x073F	; 0x80073f <uxTopUsedPriority>
     e6a:	98 17       	cp	r25, r24
     e6c:	10 f4       	brcc	.+4      	; 0xe72 <xTaskGenericCreate+0x160>
     e6e:	80 93 3f 07 	sts	0x073F, r24	; 0x80073f <uxTopUsedPriority>
     e72:	90 91 38 07 	lds	r25, 0x0738	; 0x800738 <uxTaskNumber>
     e76:	9f 5f       	subi	r25, 0xFF	; 255
     e78:	90 93 38 07 	sts	0x0738, r25	; 0x800738 <uxTaskNumber>
     e7c:	90 91 3e 07 	lds	r25, 0x073E	; 0x80073e <uxTopReadyPriority>
     e80:	98 17       	cp	r25, r24
     e82:	10 f4       	brcc	.+4      	; 0xe88 <xTaskGenericCreate+0x176>
     e84:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <uxTopReadyPriority>
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	9c 01       	movw	r18, r24
     e8c:	22 0f       	add	r18, r18
     e8e:	33 1f       	adc	r19, r19
     e90:	22 0f       	add	r18, r18
     e92:	33 1f       	adc	r19, r19
     e94:	22 0f       	add	r18, r18
     e96:	33 1f       	adc	r19, r19
     e98:	82 0f       	add	r24, r18
     e9a:	93 1f       	adc	r25, r19
     e9c:	b6 01       	movw	r22, r12
     e9e:	84 59       	subi	r24, 0x94	; 148
     ea0:	98 4f       	sbci	r25, 0xF8	; 248
     ea2:	66 d9       	rcall	.-3380   	; 0x170 <vListInsertEnd>
     ea4:	0f 90       	pop	r0
     ea6:	0f be       	out	0x3f, r0	; 63
     ea8:	80 91 3d 07 	lds	r24, 0x073D	; 0x80073d <xSchedulerRunning>
     eac:	88 23       	and	r24, r24
     eae:	51 f0       	breq	.+20     	; 0xec4 <xTaskGenericCreate+0x1b2>
     eb0:	e0 91 90 07 	lds	r30, 0x0790	; 0x800790 <pxCurrentTCB>
     eb4:	f0 91 91 07 	lds	r31, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
     eb8:	86 89       	ldd	r24, Z+22	; 0x16
     eba:	80 17       	cp	r24, r16
     ebc:	28 f4       	brcc	.+10     	; 0xec8 <xTaskGenericCreate+0x1b6>
     ebe:	41 de       	rcall	.-894    	; 0xb42 <vPortYield>
     ec0:	81 e0       	ldi	r24, 0x01	; 1
     ec2:	09 c0       	rjmp	.+18     	; 0xed6 <xTaskGenericCreate+0x1c4>
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	07 c0       	rjmp	.+14     	; 0xed6 <xTaskGenericCreate+0x1c4>
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	05 c0       	rjmp	.+10     	; 0xed6 <xTaskGenericCreate+0x1c4>
     ecc:	d8 8e       	std	Y+24, r13	; 0x18
     ece:	cf 8a       	std	Y+23, r12	; 0x17
     ed0:	c6 01       	movw	r24, r12
     ed2:	47 cf       	rjmp	.-370    	; 0xd62 <xTaskGenericCreate+0x50>
     ed4:	8f ef       	ldi	r24, 0xFF	; 255
     ed6:	df 91       	pop	r29
     ed8:	cf 91       	pop	r28
     eda:	1f 91       	pop	r17
     edc:	0f 91       	pop	r16
     ede:	ff 90       	pop	r15
     ee0:	ef 90       	pop	r14
     ee2:	df 90       	pop	r13
     ee4:	cf 90       	pop	r12
     ee6:	bf 90       	pop	r11
     ee8:	af 90       	pop	r10
     eea:	9f 90       	pop	r9
     eec:	8f 90       	pop	r8
     eee:	7f 90       	pop	r7
     ef0:	6f 90       	pop	r6
     ef2:	5f 90       	pop	r5
     ef4:	4f 90       	pop	r4
     ef6:	08 95       	ret

00000ef8 <vTaskStartScheduler>:
     ef8:	af 92       	push	r10
     efa:	bf 92       	push	r11
     efc:	cf 92       	push	r12
     efe:	df 92       	push	r13
     f00:	ef 92       	push	r14
     f02:	ff 92       	push	r15
     f04:	0f 93       	push	r16
     f06:	a1 2c       	mov	r10, r1
     f08:	b1 2c       	mov	r11, r1
     f0a:	c1 2c       	mov	r12, r1
     f0c:	d1 2c       	mov	r13, r1
     f0e:	e1 2c       	mov	r14, r1
     f10:	f1 2c       	mov	r15, r1
     f12:	00 e0       	ldi	r16, 0x00	; 0
     f14:	20 e0       	ldi	r18, 0x00	; 0
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	45 e5       	ldi	r20, 0x55	; 85
     f1a:	50 e0       	ldi	r21, 0x00	; 0
     f1c:	6d e2       	ldi	r22, 0x2D	; 45
     f1e:	71 e0       	ldi	r23, 0x01	; 1
     f20:	88 e0       	ldi	r24, 0x08	; 8
     f22:	99 e0       	ldi	r25, 0x09	; 9
     f24:	f6 de       	rcall	.-532    	; 0xd12 <xTaskGenericCreate>
     f26:	81 30       	cpi	r24, 0x01	; 1
     f28:	41 f4       	brne	.+16     	; 0xf3a <vTaskStartScheduler+0x42>
     f2a:	f8 94       	cli
     f2c:	80 93 3d 07 	sts	0x073D, r24	; 0x80073d <xSchedulerRunning>
     f30:	10 92 41 07 	sts	0x0741, r1	; 0x800741 <xTickCount+0x1>
     f34:	10 92 40 07 	sts	0x0740, r1	; 0x800740 <xTickCount>
     f38:	ca dd       	rcall	.-1132   	; 0xace <xPortStartScheduler>
     f3a:	0f 91       	pop	r16
     f3c:	ff 90       	pop	r15
     f3e:	ef 90       	pop	r14
     f40:	df 90       	pop	r13
     f42:	cf 90       	pop	r12
     f44:	bf 90       	pop	r11
     f46:	af 90       	pop	r10
     f48:	08 95       	ret

00000f4a <vTaskSuspendAll>:
     f4a:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <uxSchedulerSuspended>
     f4e:	8f 5f       	subi	r24, 0xFF	; 255
     f50:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <uxSchedulerSuspended>
     f54:	08 95       	ret

00000f56 <vTaskIncrementTick>:
     f56:	0f 93       	push	r16
     f58:	1f 93       	push	r17
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <uxSchedulerSuspended>
     f62:	81 11       	cpse	r24, r1
     f64:	af c0       	rjmp	.+350    	; 0x10c4 <vTaskIncrementTick+0x16e>
     f66:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <xTickCount>
     f6a:	90 91 41 07 	lds	r25, 0x0741	; 0x800741 <xTickCount+0x1>
     f6e:	01 96       	adiw	r24, 0x01	; 1
     f70:	90 93 41 07 	sts	0x0741, r25	; 0x800741 <xTickCount+0x1>
     f74:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <xTickCount>
     f78:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <xTickCount>
     f7c:	90 91 41 07 	lds	r25, 0x0741	; 0x800741 <xTickCount+0x1>
     f80:	89 2b       	or	r24, r25
     f82:	99 f5       	brne	.+102    	; 0xfea <vTaskIncrementTick+0x94>
     f84:	80 91 58 07 	lds	r24, 0x0758	; 0x800758 <pxDelayedTaskList>
     f88:	90 91 59 07 	lds	r25, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
     f8c:	20 91 56 07 	lds	r18, 0x0756	; 0x800756 <pxOverflowDelayedTaskList>
     f90:	30 91 57 07 	lds	r19, 0x0757	; 0x800757 <pxOverflowDelayedTaskList+0x1>
     f94:	30 93 59 07 	sts	0x0759, r19	; 0x800759 <pxDelayedTaskList+0x1>
     f98:	20 93 58 07 	sts	0x0758, r18	; 0x800758 <pxDelayedTaskList>
     f9c:	90 93 57 07 	sts	0x0757, r25	; 0x800757 <pxOverflowDelayedTaskList+0x1>
     fa0:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <pxOverflowDelayedTaskList>
     fa4:	80 91 39 07 	lds	r24, 0x0739	; 0x800739 <xNumOfOverflows>
     fa8:	8f 5f       	subi	r24, 0xFF	; 255
     faa:	80 93 39 07 	sts	0x0739, r24	; 0x800739 <xNumOfOverflows>
     fae:	e0 91 58 07 	lds	r30, 0x0758	; 0x800758 <pxDelayedTaskList>
     fb2:	f0 91 59 07 	lds	r31, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
     fb6:	80 81       	ld	r24, Z
     fb8:	81 11       	cpse	r24, r1
     fba:	07 c0       	rjmp	.+14     	; 0xfca <vTaskIncrementTick+0x74>
     fbc:	8f ef       	ldi	r24, 0xFF	; 255
     fbe:	9f ef       	ldi	r25, 0xFF	; 255
     fc0:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <xNextTaskUnblockTime+0x1>
     fc4:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <xNextTaskUnblockTime>
     fc8:	10 c0       	rjmp	.+32     	; 0xfea <vTaskIncrementTick+0x94>
     fca:	e0 91 58 07 	lds	r30, 0x0758	; 0x800758 <pxDelayedTaskList>
     fce:	f0 91 59 07 	lds	r31, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
     fd2:	05 80       	ldd	r0, Z+5	; 0x05
     fd4:	f6 81       	ldd	r31, Z+6	; 0x06
     fd6:	e0 2d       	mov	r30, r0
     fd8:	06 80       	ldd	r0, Z+6	; 0x06
     fda:	f7 81       	ldd	r31, Z+7	; 0x07
     fdc:	e0 2d       	mov	r30, r0
     fde:	82 81       	ldd	r24, Z+2	; 0x02
     fe0:	93 81       	ldd	r25, Z+3	; 0x03
     fe2:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <xNextTaskUnblockTime+0x1>
     fe6:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <xNextTaskUnblockTime>
     fea:	20 91 40 07 	lds	r18, 0x0740	; 0x800740 <xTickCount>
     fee:	30 91 41 07 	lds	r19, 0x0741	; 0x800741 <xTickCount+0x1>
     ff2:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <xNextTaskUnblockTime>
     ff6:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <xNextTaskUnblockTime+0x1>
     ffa:	28 17       	cp	r18, r24
     ffc:	39 07       	cpc	r19, r25
     ffe:	08 f4       	brcc	.+2      	; 0x1002 <vTaskIncrementTick+0xac>
    1000:	66 c0       	rjmp	.+204    	; 0x10ce <vTaskIncrementTick+0x178>
    1002:	e0 91 58 07 	lds	r30, 0x0758	; 0x800758 <pxDelayedTaskList>
    1006:	f0 91 59 07 	lds	r31, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
    100a:	80 81       	ld	r24, Z
    100c:	88 23       	and	r24, r24
    100e:	99 f0       	breq	.+38     	; 0x1036 <vTaskIncrementTick+0xe0>
    1010:	e0 91 58 07 	lds	r30, 0x0758	; 0x800758 <pxDelayedTaskList>
    1014:	f0 91 59 07 	lds	r31, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
    1018:	05 80       	ldd	r0, Z+5	; 0x05
    101a:	f6 81       	ldd	r31, Z+6	; 0x06
    101c:	e0 2d       	mov	r30, r0
    101e:	c6 81       	ldd	r28, Z+6	; 0x06
    1020:	d7 81       	ldd	r29, Z+7	; 0x07
    1022:	8a 81       	ldd	r24, Y+2	; 0x02
    1024:	9b 81       	ldd	r25, Y+3	; 0x03
    1026:	20 91 40 07 	lds	r18, 0x0740	; 0x800740 <xTickCount>
    102a:	30 91 41 07 	lds	r19, 0x0741	; 0x800741 <xTickCount+0x1>
    102e:	28 17       	cp	r18, r24
    1030:	39 07       	cpc	r19, r25
    1032:	f8 f4       	brcc	.+62     	; 0x1072 <vTaskIncrementTick+0x11c>
    1034:	19 c0       	rjmp	.+50     	; 0x1068 <vTaskIncrementTick+0x112>
    1036:	8f ef       	ldi	r24, 0xFF	; 255
    1038:	9f ef       	ldi	r25, 0xFF	; 255
    103a:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <xNextTaskUnblockTime+0x1>
    103e:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <xNextTaskUnblockTime>
    1042:	45 c0       	rjmp	.+138    	; 0x10ce <vTaskIncrementTick+0x178>
    1044:	e0 91 58 07 	lds	r30, 0x0758	; 0x800758 <pxDelayedTaskList>
    1048:	f0 91 59 07 	lds	r31, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
    104c:	05 80       	ldd	r0, Z+5	; 0x05
    104e:	f6 81       	ldd	r31, Z+6	; 0x06
    1050:	e0 2d       	mov	r30, r0
    1052:	c6 81       	ldd	r28, Z+6	; 0x06
    1054:	d7 81       	ldd	r29, Z+7	; 0x07
    1056:	8a 81       	ldd	r24, Y+2	; 0x02
    1058:	9b 81       	ldd	r25, Y+3	; 0x03
    105a:	20 91 40 07 	lds	r18, 0x0740	; 0x800740 <xTickCount>
    105e:	30 91 41 07 	lds	r19, 0x0741	; 0x800741 <xTickCount+0x1>
    1062:	28 17       	cp	r18, r24
    1064:	39 07       	cpc	r19, r25
    1066:	28 f4       	brcc	.+10     	; 0x1072 <vTaskIncrementTick+0x11c>
    1068:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <xNextTaskUnblockTime+0x1>
    106c:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <xNextTaskUnblockTime>
    1070:	2e c0       	rjmp	.+92     	; 0x10ce <vTaskIncrementTick+0x178>
    1072:	8e 01       	movw	r16, r28
    1074:	0e 5f       	subi	r16, 0xFE	; 254
    1076:	1f 4f       	sbci	r17, 0xFF	; 255
    1078:	c8 01       	movw	r24, r16
    107a:	dc d8       	rcall	.-3656   	; 0x234 <vListRemove>
    107c:	8c 89       	ldd	r24, Y+20	; 0x14
    107e:	9d 89       	ldd	r25, Y+21	; 0x15
    1080:	89 2b       	or	r24, r25
    1082:	19 f0       	breq	.+6      	; 0x108a <vTaskIncrementTick+0x134>
    1084:	ce 01       	movw	r24, r28
    1086:	0c 96       	adiw	r24, 0x0c	; 12
    1088:	d5 d8       	rcall	.-3670   	; 0x234 <vListRemove>
    108a:	2e 89       	ldd	r18, Y+22	; 0x16
    108c:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    1090:	82 17       	cp	r24, r18
    1092:	10 f4       	brcc	.+4      	; 0x1098 <vTaskIncrementTick+0x142>
    1094:	20 93 3e 07 	sts	0x073E, r18	; 0x80073e <uxTopReadyPriority>
    1098:	30 e0       	ldi	r19, 0x00	; 0
    109a:	c9 01       	movw	r24, r18
    109c:	88 0f       	add	r24, r24
    109e:	99 1f       	adc	r25, r25
    10a0:	88 0f       	add	r24, r24
    10a2:	99 1f       	adc	r25, r25
    10a4:	88 0f       	add	r24, r24
    10a6:	99 1f       	adc	r25, r25
    10a8:	82 0f       	add	r24, r18
    10aa:	93 1f       	adc	r25, r19
    10ac:	b8 01       	movw	r22, r16
    10ae:	84 59       	subi	r24, 0x94	; 148
    10b0:	98 4f       	sbci	r25, 0xF8	; 248
    10b2:	5e d8       	rcall	.-3908   	; 0x170 <vListInsertEnd>
    10b4:	e0 91 58 07 	lds	r30, 0x0758	; 0x800758 <pxDelayedTaskList>
    10b8:	f0 91 59 07 	lds	r31, 0x0759	; 0x800759 <pxDelayedTaskList+0x1>
    10bc:	80 81       	ld	r24, Z
    10be:	81 11       	cpse	r24, r1
    10c0:	c1 cf       	rjmp	.-126    	; 0x1044 <vTaskIncrementTick+0xee>
    10c2:	b9 cf       	rjmp	.-142    	; 0x1036 <vTaskIncrementTick+0xe0>
    10c4:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxMissedTicks>
    10c8:	8f 5f       	subi	r24, 0xFF	; 255
    10ca:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <uxMissedTicks>
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	08 95       	ret

000010d8 <xTaskResumeAll>:
    10d8:	cf 92       	push	r12
    10da:	df 92       	push	r13
    10dc:	ef 92       	push	r14
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
    10e8:	0f b6       	in	r0, 0x3f	; 63
    10ea:	f8 94       	cli
    10ec:	0f 92       	push	r0
    10ee:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <uxSchedulerSuspended>
    10f2:	81 50       	subi	r24, 0x01	; 1
    10f4:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <uxSchedulerSuspended>
    10f8:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <uxSchedulerSuspended>
    10fc:	81 11       	cpse	r24, r1
    10fe:	5f c0       	rjmp	.+190    	; 0x11be <xTaskResumeAll+0xe6>
    1100:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <uxCurrentNumberOfTasks>
    1104:	81 11       	cpse	r24, r1
    1106:	2f c0       	rjmp	.+94     	; 0x1166 <xTaskResumeAll+0x8e>
    1108:	5d c0       	rjmp	.+186    	; 0x11c4 <xTaskResumeAll+0xec>
    110a:	d7 01       	movw	r26, r14
    110c:	15 96       	adiw	r26, 0x05	; 5
    110e:	ed 91       	ld	r30, X+
    1110:	fc 91       	ld	r31, X
    1112:	16 97       	sbiw	r26, 0x06	; 6
    1114:	c6 81       	ldd	r28, Z+6	; 0x06
    1116:	d7 81       	ldd	r29, Z+7	; 0x07
    1118:	ce 01       	movw	r24, r28
    111a:	0c 96       	adiw	r24, 0x0c	; 12
    111c:	8b d8       	rcall	.-3818   	; 0x234 <vListRemove>
    111e:	8e 01       	movw	r16, r28
    1120:	0e 5f       	subi	r16, 0xFE	; 254
    1122:	1f 4f       	sbci	r17, 0xFF	; 255
    1124:	c8 01       	movw	r24, r16
    1126:	86 d8       	rcall	.-3828   	; 0x234 <vListRemove>
    1128:	2e 89       	ldd	r18, Y+22	; 0x16
    112a:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    112e:	82 17       	cp	r24, r18
    1130:	10 f4       	brcc	.+4      	; 0x1136 <xTaskResumeAll+0x5e>
    1132:	20 93 3e 07 	sts	0x073E, r18	; 0x80073e <uxTopReadyPriority>
    1136:	30 e0       	ldi	r19, 0x00	; 0
    1138:	c9 01       	movw	r24, r18
    113a:	88 0f       	add	r24, r24
    113c:	99 1f       	adc	r25, r25
    113e:	88 0f       	add	r24, r24
    1140:	99 1f       	adc	r25, r25
    1142:	88 0f       	add	r24, r24
    1144:	99 1f       	adc	r25, r25
    1146:	82 0f       	add	r24, r18
    1148:	93 1f       	adc	r25, r19
    114a:	b8 01       	movw	r22, r16
    114c:	84 59       	subi	r24, 0x94	; 148
    114e:	98 4f       	sbci	r25, 0xF8	; 248
    1150:	0f d8       	rcall	.-4066   	; 0x170 <vListInsertEnd>
    1152:	e0 91 90 07 	lds	r30, 0x0790	; 0x800790 <pxCurrentTCB>
    1156:	f0 91 91 07 	lds	r31, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
    115a:	9e 89       	ldd	r25, Y+22	; 0x16
    115c:	86 89       	ldd	r24, Z+22	; 0x16
    115e:	98 17       	cp	r25, r24
    1160:	58 f0       	brcs	.+22     	; 0x1178 <xTaskResumeAll+0xa0>
    1162:	dc 2c       	mov	r13, r12
    1164:	09 c0       	rjmp	.+18     	; 0x1178 <xTaskResumeAll+0xa0>
    1166:	d1 2c       	mov	r13, r1
    1168:	0f 2e       	mov	r0, r31
    116a:	fd e4       	ldi	r31, 0x4D	; 77
    116c:	ef 2e       	mov	r14, r31
    116e:	f7 e0       	ldi	r31, 0x07	; 7
    1170:	ff 2e       	mov	r15, r31
    1172:	f0 2d       	mov	r31, r0
    1174:	cc 24       	eor	r12, r12
    1176:	c3 94       	inc	r12
    1178:	f7 01       	movw	r30, r14
    117a:	80 81       	ld	r24, Z
    117c:	81 11       	cpse	r24, r1
    117e:	c5 cf       	rjmp	.-118    	; 0x110a <xTaskResumeAll+0x32>
    1180:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxMissedTicks>
    1184:	88 23       	and	r24, r24
    1186:	79 f0       	breq	.+30     	; 0x11a6 <xTaskResumeAll+0xce>
    1188:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxMissedTicks>
    118c:	88 23       	and	r24, r24
    118e:	91 f0       	breq	.+36     	; 0x11b4 <xTaskResumeAll+0xdc>
    1190:	e2 de       	rcall	.-572    	; 0xf56 <vTaskIncrementTick>
    1192:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxMissedTicks>
    1196:	81 50       	subi	r24, 0x01	; 1
    1198:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <uxMissedTicks>
    119c:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxMissedTicks>
    11a0:	81 11       	cpse	r24, r1
    11a2:	f6 cf       	rjmp	.-20     	; 0x1190 <xTaskResumeAll+0xb8>
    11a4:	07 c0       	rjmp	.+14     	; 0x11b4 <xTaskResumeAll+0xdc>
    11a6:	f1 e0       	ldi	r31, 0x01	; 1
    11a8:	df 16       	cp	r13, r31
    11aa:	21 f0       	breq	.+8      	; 0x11b4 <xTaskResumeAll+0xdc>
    11ac:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <xMissedYield>
    11b0:	81 30       	cpi	r24, 0x01	; 1
    11b2:	39 f4       	brne	.+14     	; 0x11c2 <xTaskResumeAll+0xea>
    11b4:	10 92 3a 07 	sts	0x073A, r1	; 0x80073a <xMissedYield>
    11b8:	c4 dc       	rcall	.-1656   	; 0xb42 <vPortYield>
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	03 c0       	rjmp	.+6      	; 0x11c4 <xTaskResumeAll+0xec>
    11be:	80 e0       	ldi	r24, 0x00	; 0
    11c0:	01 c0       	rjmp	.+2      	; 0x11c4 <xTaskResumeAll+0xec>
    11c2:	80 e0       	ldi	r24, 0x00	; 0
    11c4:	0f 90       	pop	r0
    11c6:	0f be       	out	0x3f, r0	; 63
    11c8:	df 91       	pop	r29
    11ca:	cf 91       	pop	r28
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	ff 90       	pop	r15
    11d2:	ef 90       	pop	r14
    11d4:	df 90       	pop	r13
    11d6:	cf 90       	pop	r12
    11d8:	08 95       	ret

000011da <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    11e0:	89 2b       	or	r24, r25
    11e2:	91 f0       	breq	.+36     	; 0x1208 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
    11e4:	b2 de       	rcall	.-668    	; 0xf4a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    11e6:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <xTickCount>
    11ea:	90 91 41 07 	lds	r25, 0x0741	; 0x800741 <xTickCount+0x1>
    11ee:	c8 0f       	add	r28, r24
    11f0:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11f2:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <pxCurrentTCB>
    11f6:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <pxCurrentTCB+0x1>
    11fa:	02 96       	adiw	r24, 0x02	; 2
    11fc:	1b d8       	rcall	.-4042   	; 0x234 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    11fe:	ce 01       	movw	r24, r28
    1200:	53 dd       	rcall	.-1370   	; 0xca8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1202:	6a df       	rcall	.-300    	; 0x10d8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1204:	81 11       	cpse	r24, r1
    1206:	01 c0       	rjmp	.+2      	; 0x120a <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    1208:	9c dc       	rcall	.-1736   	; 0xb42 <vPortYield>
		}
	}
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	08 95       	ret

00001210 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1210:	0f 2e       	mov	r0, r31
    1212:	f4 e4       	ldi	r31, 0x44	; 68
    1214:	ef 2e       	mov	r14, r31
    1216:	f7 e0       	ldi	r31, 0x07	; 7
    1218:	ff 2e       	mov	r15, r31
    121a:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    121c:	cc e6       	ldi	r28, 0x6C	; 108
    121e:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1220:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTasksDeleted>
    1224:	88 23       	and	r24, r24
    1226:	41 f1       	breq	.+80     	; 0x1278 <prvIdleTask+0x68>
		{
			vTaskSuspendAll();
    1228:	90 de       	rcall	.-736    	; 0xf4a <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    122a:	d7 01       	movw	r26, r14
    122c:	1c 91       	ld	r17, X
			xTaskResumeAll();
    122e:	54 df       	rcall	.-344    	; 0x10d8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1230:	11 23       	and	r17, r17
    1232:	11 f1       	breq	.+68     	; 0x1278 <prvIdleTask+0x68>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    123a:	d7 01       	movw	r26, r14
    123c:	15 96       	adiw	r26, 0x05	; 5
    123e:	ed 91       	ld	r30, X+
    1240:	fc 91       	ld	r31, X
    1242:	16 97       	sbiw	r26, 0x06	; 6
    1244:	06 81       	ldd	r16, Z+6	; 0x06
    1246:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1248:	c8 01       	movw	r24, r16
    124a:	02 96       	adiw	r24, 0x02	; 2
    124c:	0e 94 1a 01 	call	0x234	; 0x234 <vListRemove>
					--uxCurrentNumberOfTasks;
    1250:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <uxCurrentNumberOfTasks>
    1254:	81 50       	subi	r24, 0x01	; 1
    1256:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    125a:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTasksDeleted>
    125e:	81 50       	subi	r24, 0x01	; 1
    1260:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1264:	0f 90       	pop	r0
    1266:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1268:	f8 01       	movw	r30, r16
    126a:	87 89       	ldd	r24, Z+23	; 0x17
    126c:	90 8d       	ldd	r25, Z+24	; 0x18
    126e:	0e 94 a5 00 	call	0x14a	; 0x14a <vPortFree>
		vPortFree( pxTCB );
    1272:	c8 01       	movw	r24, r16
    1274:	0e 94 a5 00 	call	0x14a	; 0x14a <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1278:	88 81       	ld	r24, Y
    127a:	82 30       	cpi	r24, 0x02	; 2
    127c:	88 f2       	brcs	.-94     	; 0x1220 <prvIdleTask+0x10>
			{
				taskYIELD();
    127e:	61 dc       	rcall	.-1854   	; 0xb42 <vPortYield>
    1280:	cf cf       	rjmp	.-98     	; 0x1220 <prvIdleTask+0x10>

00001282 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1282:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <uxSchedulerSuspended>
    1286:	81 11       	cpse	r24, r1
    1288:	13 c0       	rjmp	.+38     	; 0x12b0 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    128a:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	fc 01       	movw	r30, r24
    1292:	ee 0f       	add	r30, r30
    1294:	ff 1f       	adc	r31, r31
    1296:	ee 0f       	add	r30, r30
    1298:	ff 1f       	adc	r31, r31
    129a:	ee 0f       	add	r30, r30
    129c:	ff 1f       	adc	r31, r31
    129e:	8e 0f       	add	r24, r30
    12a0:	9f 1f       	adc	r25, r31
    12a2:	fc 01       	movw	r30, r24
    12a4:	e4 59       	subi	r30, 0x94	; 148
    12a6:	f8 4f       	sbci	r31, 0xF8	; 248
    12a8:	80 81       	ld	r24, Z
    12aa:	88 23       	and	r24, r24
    12ac:	29 f0       	breq	.+10     	; 0x12b8 <vTaskSwitchContext+0x36>
    12ae:	1b c0       	rjmp	.+54     	; 0x12e6 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	80 93 3a 07 	sts	0x073A, r24	; 0x80073a <xMissedYield>
    12b6:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    12b8:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    12bc:	81 50       	subi	r24, 0x01	; 1
    12be:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    12c2:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    12c6:	90 e0       	ldi	r25, 0x00	; 0
    12c8:	fc 01       	movw	r30, r24
    12ca:	ee 0f       	add	r30, r30
    12cc:	ff 1f       	adc	r31, r31
    12ce:	ee 0f       	add	r30, r30
    12d0:	ff 1f       	adc	r31, r31
    12d2:	ee 0f       	add	r30, r30
    12d4:	ff 1f       	adc	r31, r31
    12d6:	8e 0f       	add	r24, r30
    12d8:	9f 1f       	adc	r25, r31
    12da:	fc 01       	movw	r30, r24
    12dc:	e4 59       	subi	r30, 0x94	; 148
    12de:	f8 4f       	sbci	r31, 0xF8	; 248
    12e0:	80 81       	ld	r24, Z
    12e2:	88 23       	and	r24, r24
    12e4:	49 f3       	breq	.-46     	; 0x12b8 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    12e6:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <uxTopReadyPriority>
    12ea:	90 e0       	ldi	r25, 0x00	; 0
    12ec:	9c 01       	movw	r18, r24
    12ee:	22 0f       	add	r18, r18
    12f0:	33 1f       	adc	r19, r19
    12f2:	22 0f       	add	r18, r18
    12f4:	33 1f       	adc	r19, r19
    12f6:	22 0f       	add	r18, r18
    12f8:	33 1f       	adc	r19, r19
    12fa:	28 0f       	add	r18, r24
    12fc:	39 1f       	adc	r19, r25
    12fe:	d9 01       	movw	r26, r18
    1300:	a4 59       	subi	r26, 0x94	; 148
    1302:	b8 4f       	sbci	r27, 0xF8	; 248
    1304:	11 96       	adiw	r26, 0x01	; 1
    1306:	ed 91       	ld	r30, X+
    1308:	fc 91       	ld	r31, X
    130a:	12 97       	sbiw	r26, 0x02	; 2
    130c:	02 80       	ldd	r0, Z+2	; 0x02
    130e:	f3 81       	ldd	r31, Z+3	; 0x03
    1310:	e0 2d       	mov	r30, r0
    1312:	12 96       	adiw	r26, 0x02	; 2
    1314:	fc 93       	st	X, r31
    1316:	ee 93       	st	-X, r30
    1318:	11 97       	sbiw	r26, 0x01	; 1
    131a:	21 59       	subi	r18, 0x91	; 145
    131c:	38 4f       	sbci	r19, 0xF8	; 248
    131e:	e2 17       	cp	r30, r18
    1320:	f3 07       	cpc	r31, r19
    1322:	29 f4       	brne	.+10     	; 0x132e <vTaskSwitchContext+0xac>
    1324:	22 81       	ldd	r18, Z+2	; 0x02
    1326:	33 81       	ldd	r19, Z+3	; 0x03
    1328:	fd 01       	movw	r30, r26
    132a:	32 83       	std	Z+2, r19	; 0x02
    132c:	21 83       	std	Z+1, r18	; 0x01
    132e:	fc 01       	movw	r30, r24
    1330:	ee 0f       	add	r30, r30
    1332:	ff 1f       	adc	r31, r31
    1334:	ee 0f       	add	r30, r30
    1336:	ff 1f       	adc	r31, r31
    1338:	ee 0f       	add	r30, r30
    133a:	ff 1f       	adc	r31, r31
    133c:	8e 0f       	add	r24, r30
    133e:	9f 1f       	adc	r25, r31
    1340:	fc 01       	movw	r30, r24
    1342:	e4 59       	subi	r30, 0x94	; 148
    1344:	f8 4f       	sbci	r31, 0xF8	; 248
    1346:	01 80       	ldd	r0, Z+1	; 0x01
    1348:	f2 81       	ldd	r31, Z+2	; 0x02
    134a:	e0 2d       	mov	r30, r0
    134c:	86 81       	ldd	r24, Z+6	; 0x06
    134e:	97 81       	ldd	r25, Z+7	; 0x07
    1350:	90 93 91 07 	sts	0x0791, r25	; 0x800791 <pxCurrentTCB+0x1>
    1354:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <pxCurrentTCB>
    1358:	08 95       	ret

0000135a <__tablejump2__>:
    135a:	ee 0f       	add	r30, r30
    135c:	ff 1f       	adc	r31, r31
    135e:	00 24       	eor	r0, r0
    1360:	00 1c       	adc	r0, r0
    1362:	0b be       	out	0x3b, r0	; 59
    1364:	07 90       	elpm	r0, Z+
    1366:	f6 91       	elpm	r31, Z
    1368:	e0 2d       	mov	r30, r0
    136a:	09 94       	ijmp

0000136c <do_rand>:
    136c:	8f 92       	push	r8
    136e:	9f 92       	push	r9
    1370:	af 92       	push	r10
    1372:	bf 92       	push	r11
    1374:	cf 92       	push	r12
    1376:	df 92       	push	r13
    1378:	ef 92       	push	r14
    137a:	ff 92       	push	r15
    137c:	cf 93       	push	r28
    137e:	df 93       	push	r29
    1380:	ec 01       	movw	r28, r24
    1382:	68 81       	ld	r22, Y
    1384:	79 81       	ldd	r23, Y+1	; 0x01
    1386:	8a 81       	ldd	r24, Y+2	; 0x02
    1388:	9b 81       	ldd	r25, Y+3	; 0x03
    138a:	61 15       	cp	r22, r1
    138c:	71 05       	cpc	r23, r1
    138e:	81 05       	cpc	r24, r1
    1390:	91 05       	cpc	r25, r1
    1392:	21 f4       	brne	.+8      	; 0x139c <do_rand+0x30>
    1394:	64 e2       	ldi	r22, 0x24	; 36
    1396:	79 ed       	ldi	r23, 0xD9	; 217
    1398:	8b e5       	ldi	r24, 0x5B	; 91
    139a:	97 e0       	ldi	r25, 0x07	; 7
    139c:	2d e1       	ldi	r18, 0x1D	; 29
    139e:	33 ef       	ldi	r19, 0xF3	; 243
    13a0:	41 e0       	ldi	r20, 0x01	; 1
    13a2:	50 e0       	ldi	r21, 0x00	; 0
    13a4:	4e d0       	rcall	.+156    	; 0x1442 <__divmodsi4>
    13a6:	49 01       	movw	r8, r18
    13a8:	5a 01       	movw	r10, r20
    13aa:	9b 01       	movw	r18, r22
    13ac:	ac 01       	movw	r20, r24
    13ae:	a7 ea       	ldi	r26, 0xA7	; 167
    13b0:	b1 e4       	ldi	r27, 0x41	; 65
    13b2:	63 d0       	rcall	.+198    	; 0x147a <__muluhisi3>
    13b4:	6b 01       	movw	r12, r22
    13b6:	7c 01       	movw	r14, r24
    13b8:	ac ee       	ldi	r26, 0xEC	; 236
    13ba:	b4 ef       	ldi	r27, 0xF4	; 244
    13bc:	a5 01       	movw	r20, r10
    13be:	94 01       	movw	r18, r8
    13c0:	68 d0       	rcall	.+208    	; 0x1492 <__mulohisi3>
    13c2:	dc 01       	movw	r26, r24
    13c4:	cb 01       	movw	r24, r22
    13c6:	8c 0d       	add	r24, r12
    13c8:	9d 1d       	adc	r25, r13
    13ca:	ae 1d       	adc	r26, r14
    13cc:	bf 1d       	adc	r27, r15
    13ce:	b7 ff       	sbrs	r27, 7
    13d0:	03 c0       	rjmp	.+6      	; 0x13d8 <do_rand+0x6c>
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	a1 09       	sbc	r26, r1
    13d6:	b0 48       	sbci	r27, 0x80	; 128
    13d8:	88 83       	st	Y, r24
    13da:	99 83       	std	Y+1, r25	; 0x01
    13dc:	aa 83       	std	Y+2, r26	; 0x02
    13de:	bb 83       	std	Y+3, r27	; 0x03
    13e0:	9f 77       	andi	r25, 0x7F	; 127
    13e2:	df 91       	pop	r29
    13e4:	cf 91       	pop	r28
    13e6:	ff 90       	pop	r15
    13e8:	ef 90       	pop	r14
    13ea:	df 90       	pop	r13
    13ec:	cf 90       	pop	r12
    13ee:	bf 90       	pop	r11
    13f0:	af 90       	pop	r10
    13f2:	9f 90       	pop	r9
    13f4:	8f 90       	pop	r8
    13f6:	08 95       	ret

000013f8 <rand_r>:
    13f8:	b9 cf       	rjmp	.-142    	; 0x136c <do_rand>

000013fa <rand>:
    13fa:	80 e0       	ldi	r24, 0x00	; 0
    13fc:	91 e0       	ldi	r25, 0x01	; 1
    13fe:	b6 cf       	rjmp	.-148    	; 0x136c <do_rand>

00001400 <srand>:
    1400:	a0 e0       	ldi	r26, 0x00	; 0
    1402:	b0 e0       	ldi	r27, 0x00	; 0
    1404:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    1408:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
    140c:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
    1410:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
    1414:	08 95       	ret

00001416 <memset>:
    1416:	dc 01       	movw	r26, r24
    1418:	01 c0       	rjmp	.+2      	; 0x141c <memset+0x6>
    141a:	6d 93       	st	X+, r22
    141c:	41 50       	subi	r20, 0x01	; 1
    141e:	50 40       	sbci	r21, 0x00	; 0
    1420:	e0 f7       	brcc	.-8      	; 0x141a <memset+0x4>
    1422:	08 95       	ret

00001424 <strncpy>:
    1424:	fb 01       	movw	r30, r22
    1426:	dc 01       	movw	r26, r24
    1428:	41 50       	subi	r20, 0x01	; 1
    142a:	50 40       	sbci	r21, 0x00	; 0
    142c:	48 f0       	brcs	.+18     	; 0x1440 <strncpy+0x1c>
    142e:	01 90       	ld	r0, Z+
    1430:	0d 92       	st	X+, r0
    1432:	00 20       	and	r0, r0
    1434:	c9 f7       	brne	.-14     	; 0x1428 <strncpy+0x4>
    1436:	01 c0       	rjmp	.+2      	; 0x143a <strncpy+0x16>
    1438:	1d 92       	st	X+, r1
    143a:	41 50       	subi	r20, 0x01	; 1
    143c:	50 40       	sbci	r21, 0x00	; 0
    143e:	e0 f7       	brcc	.-8      	; 0x1438 <strncpy+0x14>
    1440:	08 95       	ret

00001442 <__divmodsi4>:
    1442:	05 2e       	mov	r0, r21
    1444:	97 fb       	bst	r25, 7
    1446:	16 f4       	brtc	.+4      	; 0x144c <__divmodsi4+0xa>
    1448:	00 94       	com	r0
    144a:	0f d0       	rcall	.+30     	; 0x146a <__negsi2>
    144c:	57 fd       	sbrc	r21, 7
    144e:	05 d0       	rcall	.+10     	; 0x145a <__divmodsi4_neg2>
    1450:	24 d0       	rcall	.+72     	; 0x149a <__udivmodsi4>
    1452:	07 fc       	sbrc	r0, 7
    1454:	02 d0       	rcall	.+4      	; 0x145a <__divmodsi4_neg2>
    1456:	46 f4       	brtc	.+16     	; 0x1468 <__divmodsi4_exit>
    1458:	08 c0       	rjmp	.+16     	; 0x146a <__negsi2>

0000145a <__divmodsi4_neg2>:
    145a:	50 95       	com	r21
    145c:	40 95       	com	r20
    145e:	30 95       	com	r19
    1460:	21 95       	neg	r18
    1462:	3f 4f       	sbci	r19, 0xFF	; 255
    1464:	4f 4f       	sbci	r20, 0xFF	; 255
    1466:	5f 4f       	sbci	r21, 0xFF	; 255

00001468 <__divmodsi4_exit>:
    1468:	08 95       	ret

0000146a <__negsi2>:
    146a:	90 95       	com	r25
    146c:	80 95       	com	r24
    146e:	70 95       	com	r23
    1470:	61 95       	neg	r22
    1472:	7f 4f       	sbci	r23, 0xFF	; 255
    1474:	8f 4f       	sbci	r24, 0xFF	; 255
    1476:	9f 4f       	sbci	r25, 0xFF	; 255
    1478:	08 95       	ret

0000147a <__muluhisi3>:
    147a:	31 d0       	rcall	.+98     	; 0x14de <__umulhisi3>
    147c:	a5 9f       	mul	r26, r21
    147e:	90 0d       	add	r25, r0
    1480:	b4 9f       	mul	r27, r20
    1482:	90 0d       	add	r25, r0
    1484:	a4 9f       	mul	r26, r20
    1486:	80 0d       	add	r24, r0
    1488:	91 1d       	adc	r25, r1
    148a:	11 24       	eor	r1, r1
    148c:	08 95       	ret

0000148e <__mulshisi3>:
    148e:	b7 ff       	sbrs	r27, 7
    1490:	f4 cf       	rjmp	.-24     	; 0x147a <__muluhisi3>

00001492 <__mulohisi3>:
    1492:	f3 df       	rcall	.-26     	; 0x147a <__muluhisi3>
    1494:	82 1b       	sub	r24, r18
    1496:	93 0b       	sbc	r25, r19
    1498:	08 95       	ret

0000149a <__udivmodsi4>:
    149a:	a1 e2       	ldi	r26, 0x21	; 33
    149c:	1a 2e       	mov	r1, r26
    149e:	aa 1b       	sub	r26, r26
    14a0:	bb 1b       	sub	r27, r27
    14a2:	fd 01       	movw	r30, r26
    14a4:	0d c0       	rjmp	.+26     	; 0x14c0 <__udivmodsi4_ep>

000014a6 <__udivmodsi4_loop>:
    14a6:	aa 1f       	adc	r26, r26
    14a8:	bb 1f       	adc	r27, r27
    14aa:	ee 1f       	adc	r30, r30
    14ac:	ff 1f       	adc	r31, r31
    14ae:	a2 17       	cp	r26, r18
    14b0:	b3 07       	cpc	r27, r19
    14b2:	e4 07       	cpc	r30, r20
    14b4:	f5 07       	cpc	r31, r21
    14b6:	20 f0       	brcs	.+8      	; 0x14c0 <__udivmodsi4_ep>
    14b8:	a2 1b       	sub	r26, r18
    14ba:	b3 0b       	sbc	r27, r19
    14bc:	e4 0b       	sbc	r30, r20
    14be:	f5 0b       	sbc	r31, r21

000014c0 <__udivmodsi4_ep>:
    14c0:	66 1f       	adc	r22, r22
    14c2:	77 1f       	adc	r23, r23
    14c4:	88 1f       	adc	r24, r24
    14c6:	99 1f       	adc	r25, r25
    14c8:	1a 94       	dec	r1
    14ca:	69 f7       	brne	.-38     	; 0x14a6 <__udivmodsi4_loop>
    14cc:	60 95       	com	r22
    14ce:	70 95       	com	r23
    14d0:	80 95       	com	r24
    14d2:	90 95       	com	r25
    14d4:	9b 01       	movw	r18, r22
    14d6:	ac 01       	movw	r20, r24
    14d8:	bd 01       	movw	r22, r26
    14da:	cf 01       	movw	r24, r30
    14dc:	08 95       	ret

000014de <__umulhisi3>:
    14de:	a2 9f       	mul	r26, r18
    14e0:	b0 01       	movw	r22, r0
    14e2:	b3 9f       	mul	r27, r19
    14e4:	c0 01       	movw	r24, r0
    14e6:	a3 9f       	mul	r26, r19
    14e8:	70 0d       	add	r23, r0
    14ea:	81 1d       	adc	r24, r1
    14ec:	11 24       	eor	r1, r1
    14ee:	91 1d       	adc	r25, r1
    14f0:	b2 9f       	mul	r27, r18
    14f2:	70 0d       	add	r23, r0
    14f4:	81 1d       	adc	r24, r1
    14f6:	11 24       	eor	r1, r1
    14f8:	91 1d       	adc	r25, r1
    14fa:	08 95       	ret

000014fc <_exit>:
    14fc:	f8 94       	cli

000014fe <__stop_program>:
    14fe:	ff cf       	rjmp	.-2      	; 0x14fe <__stop_program>
