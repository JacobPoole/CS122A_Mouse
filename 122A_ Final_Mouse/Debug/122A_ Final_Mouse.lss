
122A_ Final_Mouse.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00000fa4  00001038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000fa4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063e  00800124  00800124  0000105c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000105c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000108c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e0  00000000  00000000  000010cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000025da  00000000  00000000  000012ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ff1  00000000  00000000  00003886  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001479  00000000  00000000  00004877  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000049c  00000000  00000000  00005cf0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d54  00000000  00000000  0000618c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001297  00000000  00000000  00006ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001d8  00000000  00000000  00008177  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	4e c0       	rjmp	.+156    	; 0x9e <__ctors_end>
   2:	00 00       	nop
   4:	69 c0       	rjmp	.+210    	; 0xd8 <__bad_interrupt>
   6:	00 00       	nop
   8:	67 c0       	rjmp	.+206    	; 0xd8 <__bad_interrupt>
   a:	00 00       	nop
   c:	65 c0       	rjmp	.+202    	; 0xd8 <__bad_interrupt>
   e:	00 00       	nop
  10:	63 c0       	rjmp	.+198    	; 0xd8 <__bad_interrupt>
  12:	00 00       	nop
  14:	61 c0       	rjmp	.+194    	; 0xd8 <__bad_interrupt>
  16:	00 00       	nop
  18:	5f c0       	rjmp	.+190    	; 0xd8 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	5d c0       	rjmp	.+186    	; 0xd8 <__bad_interrupt>
  1e:	00 00       	nop
  20:	5b c0       	rjmp	.+182    	; 0xd8 <__bad_interrupt>
  22:	00 00       	nop
  24:	59 c0       	rjmp	.+178    	; 0xd8 <__bad_interrupt>
  26:	00 00       	nop
  28:	57 c0       	rjmp	.+174    	; 0xd8 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	55 c0       	rjmp	.+170    	; 0xd8 <__bad_interrupt>
  2e:	00 00       	nop
  30:	53 c0       	rjmp	.+166    	; 0xd8 <__bad_interrupt>
  32:	00 00       	nop
  34:	65 c3       	rjmp	.+1738   	; 0x700 <__vector_13>
  36:	00 00       	nop
  38:	4f c0       	rjmp	.+158    	; 0xd8 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	4d c0       	rjmp	.+154    	; 0xd8 <__bad_interrupt>
  3e:	00 00       	nop
  40:	4b c0       	rjmp	.+150    	; 0xd8 <__bad_interrupt>
  42:	00 00       	nop
  44:	49 c0       	rjmp	.+146    	; 0xd8 <__bad_interrupt>
  46:	00 00       	nop
  48:	47 c0       	rjmp	.+142    	; 0xd8 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	45 c0       	rjmp	.+138    	; 0xd8 <__bad_interrupt>
  4e:	00 00       	nop
  50:	43 c0       	rjmp	.+134    	; 0xd8 <__bad_interrupt>
  52:	00 00       	nop
  54:	41 c0       	rjmp	.+130    	; 0xd8 <__bad_interrupt>
  56:	00 00       	nop
  58:	3f c0       	rjmp	.+126    	; 0xd8 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	3d c0       	rjmp	.+122    	; 0xd8 <__bad_interrupt>
  5e:	00 00       	nop
  60:	3b c0       	rjmp	.+118    	; 0xd8 <__bad_interrupt>
  62:	00 00       	nop
  64:	39 c0       	rjmp	.+114    	; 0xd8 <__bad_interrupt>
  66:	00 00       	nop
  68:	37 c0       	rjmp	.+110    	; 0xd8 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	35 c0       	rjmp	.+106    	; 0xd8 <__bad_interrupt>
  6e:	00 00       	nop
  70:	33 c0       	rjmp	.+102    	; 0xd8 <__bad_interrupt>
  72:	00 00       	nop
  74:	31 c0       	rjmp	.+98     	; 0xd8 <__bad_interrupt>
  76:	00 00       	nop
  78:	2f c0       	rjmp	.+94     	; 0xd8 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	2d c0       	rjmp	.+90     	; 0xd8 <__bad_interrupt>
  7e:	00 00       	nop
  80:	2b c0       	rjmp	.+86     	; 0xd8 <__bad_interrupt>
  82:	00 00       	nop
  84:	29 c0       	rjmp	.+82     	; 0xd8 <__bad_interrupt>
  86:	00 00       	nop
  88:	27 c0       	rjmp	.+78     	; 0xd8 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	8e 01       	movw	r16, r28
  8e:	92 01       	movw	r18, r4
  90:	96 01       	movw	r18, r12
  92:	b3 01       	movw	r22, r6
  94:	b7 01       	movw	r22, r14
  96:	bb 01       	movw	r22, r22
  98:	c3 01       	movw	r24, r6
  9a:	bf 01       	movw	r22, r30
  9c:	c7 01       	movw	r24, r14

0000009e <__ctors_end>:
  9e:	11 24       	eor	r1, r1
  a0:	1f be       	out	0x3f, r1	; 63
  a2:	cf ef       	ldi	r28, 0xFF	; 255
  a4:	d0 e4       	ldi	r29, 0x40	; 64
  a6:	de bf       	out	0x3e, r29	; 62
  a8:	cd bf       	out	0x3d, r28	; 61

000000aa <__do_copy_data>:
  aa:	11 e0       	ldi	r17, 0x01	; 1
  ac:	a0 e0       	ldi	r26, 0x00	; 0
  ae:	b1 e0       	ldi	r27, 0x01	; 1
  b0:	e4 ea       	ldi	r30, 0xA4	; 164
  b2:	ff e0       	ldi	r31, 0x0F	; 15
  b4:	00 e0       	ldi	r16, 0x00	; 0
  b6:	0b bf       	out	0x3b, r16	; 59
  b8:	02 c0       	rjmp	.+4      	; 0xbe <__do_copy_data+0x14>
  ba:	07 90       	elpm	r0, Z+
  bc:	0d 92       	st	X+, r0
  be:	a4 32       	cpi	r26, 0x24	; 36
  c0:	b1 07       	cpc	r27, r17
  c2:	d9 f7       	brne	.-10     	; 0xba <__do_copy_data+0x10>

000000c4 <__do_clear_bss>:
  c4:	27 e0       	ldi	r18, 0x07	; 7
  c6:	a4 e2       	ldi	r26, 0x24	; 36
  c8:	b1 e0       	ldi	r27, 0x01	; 1
  ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
  cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
  ce:	a2 36       	cpi	r26, 0x62	; 98
  d0:	b2 07       	cpc	r27, r18
  d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>
  d4:	b2 d1       	rcall	.+868    	; 0x43a <main>
  d6:	64 c7       	rjmp	.+3784   	; 0xfa0 <_exit>

000000d8 <__bad_interrupt>:
  d8:	93 cf       	rjmp	.-218    	; 0x0 <__vectors>

000000da <time>:
  da:	fc 01       	movw	r30, r24
  dc:	0f b6       	in	r0, 0x3f	; 63
  de:	f8 94       	cli
  e0:	60 91 5e 07 	lds	r22, 0x075E	; 0x80075e <__system_time>
  e4:	70 91 5f 07 	lds	r23, 0x075F	; 0x80075f <__system_time+0x1>
  e8:	80 91 60 07 	lds	r24, 0x0760	; 0x800760 <__system_time+0x2>
  ec:	90 91 61 07 	lds	r25, 0x0761	; 0x800761 <__system_time+0x3>
  f0:	0f be       	out	0x3f, r0	; 63
  f2:	30 97       	sbiw	r30, 0x00	; 0
  f4:	21 f0       	breq	.+8      	; 0xfe <time+0x24>
  f6:	60 83       	st	Z, r22
  f8:	71 83       	std	Z+1, r23	; 0x01
  fa:	82 83       	std	Z+2, r24	; 0x02
  fc:	93 83       	std	Z+3, r25	; 0x03
  fe:	08 95       	ret

00000100 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 100:	cf 93       	push	r28
 102:	df 93       	push	r29
 104:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 106:	4f d4       	rcall	.+2206   	; 0x9a6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 108:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <__data_end>
 10c:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <__data_end+0x1>
 110:	ce 01       	movw	r24, r28
 112:	82 0f       	add	r24, r18
 114:	93 1f       	adc	r25, r19
 116:	8c 3d       	cpi	r24, 0xDC	; 220
 118:	45 e0       	ldi	r20, 0x05	; 5
 11a:	94 07       	cpc	r25, r20
 11c:	58 f4       	brcc	.+22     	; 0x134 <pvPortMalloc+0x34>
 11e:	28 17       	cp	r18, r24
 120:	39 07       	cpc	r19, r25
 122:	58 f4       	brcc	.+22     	; 0x13a <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 124:	e9 01       	movw	r28, r18
 126:	ca 5d       	subi	r28, 0xDA	; 218
 128:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
 12a:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <__data_end+0x1>
 12e:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <__data_end>
 132:	05 c0       	rjmp	.+10     	; 0x13e <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
 134:	c0 e0       	ldi	r28, 0x00	; 0
 136:	d0 e0       	ldi	r29, 0x00	; 0
 138:	02 c0       	rjmp	.+4      	; 0x13e <pvPortMalloc+0x3e>
 13a:	c0 e0       	ldi	r28, 0x00	; 0
 13c:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 13e:	fa d4       	rcall	.+2548   	; 0xb34 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 140:	ce 01       	movw	r24, r28
 142:	df 91       	pop	r29
 144:	cf 91       	pop	r28
 146:	08 95       	ret

00000148 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 148:	08 95       	ret

0000014a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 14a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 14c:	03 96       	adiw	r24, 0x03	; 3
 14e:	92 83       	std	Z+2, r25	; 0x02
 150:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 152:	2f ef       	ldi	r18, 0xFF	; 255
 154:	3f ef       	ldi	r19, 0xFF	; 255
 156:	34 83       	std	Z+4, r19	; 0x04
 158:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 15a:	96 83       	std	Z+6, r25	; 0x06
 15c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 15e:	90 87       	std	Z+8, r25	; 0x08
 160:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 162:	10 82       	st	Z, r1
 164:	08 95       	ret

00000166 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 166:	fc 01       	movw	r30, r24
 168:	11 86       	std	Z+9, r1	; 0x09
 16a:	10 86       	std	Z+8, r1	; 0x08
 16c:	08 95       	ret

0000016e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 16e:	cf 93       	push	r28
 170:	df 93       	push	r29
 172:	fc 01       	movw	r30, r24
 174:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 176:	21 81       	ldd	r18, Z+1	; 0x01
 178:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 17a:	e9 01       	movw	r28, r18
 17c:	8a 81       	ldd	r24, Y+2	; 0x02
 17e:	9b 81       	ldd	r25, Y+3	; 0x03
 180:	13 96       	adiw	r26, 0x03	; 3
 182:	9c 93       	st	X, r25
 184:	8e 93       	st	-X, r24
 186:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 188:	81 81       	ldd	r24, Z+1	; 0x01
 18a:	92 81       	ldd	r25, Z+2	; 0x02
 18c:	15 96       	adiw	r26, 0x05	; 5
 18e:	9c 93       	st	X, r25
 190:	8e 93       	st	-X, r24
 192:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 194:	8a 81       	ldd	r24, Y+2	; 0x02
 196:	9b 81       	ldd	r25, Y+3	; 0x03
 198:	ec 01       	movw	r28, r24
 19a:	7d 83       	std	Y+5, r23	; 0x05
 19c:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 19e:	e9 01       	movw	r28, r18
 1a0:	7b 83       	std	Y+3, r23	; 0x03
 1a2:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 1a4:	72 83       	std	Z+2, r23	; 0x02
 1a6:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1a8:	19 96       	adiw	r26, 0x09	; 9
 1aa:	fc 93       	st	X, r31
 1ac:	ee 93       	st	-X, r30
 1ae:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 1b0:	80 81       	ld	r24, Z
 1b2:	8f 5f       	subi	r24, 0xFF	; 255
 1b4:	80 83       	st	Z, r24
}
 1b6:	df 91       	pop	r29
 1b8:	cf 91       	pop	r28
 1ba:	08 95       	ret

000001bc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 1bc:	cf 93       	push	r28
 1be:	df 93       	push	r29
 1c0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 1c2:	48 81       	ld	r20, Y
 1c4:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1c6:	4f 3f       	cpi	r20, 0xFF	; 255
 1c8:	2f ef       	ldi	r18, 0xFF	; 255
 1ca:	52 07       	cpc	r21, r18
 1cc:	31 f4       	brne	.+12     	; 0x1da <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1ce:	dc 01       	movw	r26, r24
 1d0:	17 96       	adiw	r26, 0x07	; 7
 1d2:	ed 91       	ld	r30, X+
 1d4:	fc 91       	ld	r31, X
 1d6:	18 97       	sbiw	r26, 0x08	; 8
 1d8:	17 c0       	rjmp	.+46     	; 0x208 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 1da:	fc 01       	movw	r30, r24
 1dc:	33 96       	adiw	r30, 0x03	; 3
 1de:	dc 01       	movw	r26, r24
 1e0:	15 96       	adiw	r26, 0x05	; 5
 1e2:	2d 91       	ld	r18, X+
 1e4:	3c 91       	ld	r19, X
 1e6:	16 97       	sbiw	r26, 0x06	; 6
 1e8:	d9 01       	movw	r26, r18
 1ea:	2d 91       	ld	r18, X+
 1ec:	3c 91       	ld	r19, X
 1ee:	42 17       	cp	r20, r18
 1f0:	53 07       	cpc	r21, r19
 1f2:	50 f0       	brcs	.+20     	; 0x208 <vListInsert+0x4c>
 1f4:	02 80       	ldd	r0, Z+2	; 0x02
 1f6:	f3 81       	ldd	r31, Z+3	; 0x03
 1f8:	e0 2d       	mov	r30, r0
 1fa:	a2 81       	ldd	r26, Z+2	; 0x02
 1fc:	b3 81       	ldd	r27, Z+3	; 0x03
 1fe:	2d 91       	ld	r18, X+
 200:	3c 91       	ld	r19, X
 202:	42 17       	cp	r20, r18
 204:	53 07       	cpc	r21, r19
 206:	b0 f7       	brcc	.-20     	; 0x1f4 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 208:	a2 81       	ldd	r26, Z+2	; 0x02
 20a:	b3 81       	ldd	r27, Z+3	; 0x03
 20c:	bb 83       	std	Y+3, r27	; 0x03
 20e:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 210:	15 96       	adiw	r26, 0x05	; 5
 212:	dc 93       	st	X, r29
 214:	ce 93       	st	-X, r28
 216:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 218:	fd 83       	std	Y+5, r31	; 0x05
 21a:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 21c:	d3 83       	std	Z+3, r29	; 0x03
 21e:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 220:	99 87       	std	Y+9, r25	; 0x09
 222:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 224:	fc 01       	movw	r30, r24
 226:	20 81       	ld	r18, Z
 228:	2f 5f       	subi	r18, 0xFF	; 255
 22a:	20 83       	st	Z, r18
}
 22c:	df 91       	pop	r29
 22e:	cf 91       	pop	r28
 230:	08 95       	ret

00000232 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 232:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 234:	a2 81       	ldd	r26, Z+2	; 0x02
 236:	b3 81       	ldd	r27, Z+3	; 0x03
 238:	84 81       	ldd	r24, Z+4	; 0x04
 23a:	95 81       	ldd	r25, Z+5	; 0x05
 23c:	15 96       	adiw	r26, 0x05	; 5
 23e:	9c 93       	st	X, r25
 240:	8e 93       	st	-X, r24
 242:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 244:	a4 81       	ldd	r26, Z+4	; 0x04
 246:	b5 81       	ldd	r27, Z+5	; 0x05
 248:	82 81       	ldd	r24, Z+2	; 0x02
 24a:	93 81       	ldd	r25, Z+3	; 0x03
 24c:	13 96       	adiw	r26, 0x03	; 3
 24e:	9c 93       	st	X, r25
 250:	8e 93       	st	-X, r24
 252:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 254:	a0 85       	ldd	r26, Z+8	; 0x08
 256:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 258:	11 96       	adiw	r26, 0x01	; 1
 25a:	8d 91       	ld	r24, X+
 25c:	9c 91       	ld	r25, X
 25e:	12 97       	sbiw	r26, 0x02	; 2
 260:	8e 17       	cp	r24, r30
 262:	9f 07       	cpc	r25, r31
 264:	31 f4       	brne	.+12     	; 0x272 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 266:	84 81       	ldd	r24, Z+4	; 0x04
 268:	95 81       	ldd	r25, Z+5	; 0x05
 26a:	12 96       	adiw	r26, 0x02	; 2
 26c:	9c 93       	st	X, r25
 26e:	8e 93       	st	-X, r24
 270:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 272:	11 86       	std	Z+9, r1	; 0x09
 274:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 276:	8c 91       	ld	r24, X
 278:	81 50       	subi	r24, 0x01	; 1
 27a:	8c 93       	st	X, r24
 27c:	08 95       	ret

0000027e <adc_read>:
/*
void TRACK_Init(){
	trackData = INITTrack;
}*/
void EMIT_Init(){
	emitLight = INITEmit;
 27e:	ec e7       	ldi	r30, 0x7C	; 124
 280:	f0 e0       	ldi	r31, 0x00	; 0
 282:	20 81       	ld	r18, Z
 284:	87 70       	andi	r24, 0x07	; 7
 286:	99 27       	eor	r25, r25
 288:	28 7f       	andi	r18, 0xF8	; 248
 28a:	82 2b       	or	r24, r18
 28c:	80 83       	st	Z, r24
 28e:	ea e7       	ldi	r30, 0x7A	; 122
 290:	f0 e0       	ldi	r31, 0x00	; 0
 292:	80 81       	ld	r24, Z
 294:	80 64       	ori	r24, 0x40	; 64
 296:	80 83       	st	Z, r24
 298:	80 81       	ld	r24, Z
 29a:	86 fd       	sbrc	r24, 6
 29c:	fd cf       	rjmp	.-6      	; 0x298 <adc_read+0x1a>
 29e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 2a2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 2a6:	08 95       	ret

000002a8 <MOVE_Tick>:
}

void MOVE_Tick(){
	//Actions
	switch(moveMouse){
 2a8:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <moveMouse>
 2ac:	84 30       	cpi	r24, 0x04	; 4
 2ae:	c1 f0       	breq	.+48     	; 0x2e0 <MOVE_Tick+0x38>
 2b0:	28 f4       	brcc	.+10     	; 0x2bc <MOVE_Tick+0x14>
 2b2:	88 23       	and	r24, r24
 2b4:	51 f0       	breq	.+20     	; 0x2ca <MOVE_Tick+0x22>
 2b6:	83 30       	cpi	r24, 0x03	; 3
 2b8:	81 f0       	breq	.+32     	; 0x2da <MOVE_Tick+0x32>
 2ba:	24 c0       	rjmp	.+72     	; 0x304 <MOVE_Tick+0x5c>
 2bc:	87 30       	cpi	r24, 0x07	; 7
 2be:	c9 f0       	breq	.+50     	; 0x2f2 <MOVE_Tick+0x4a>
 2c0:	88 30       	cpi	r24, 0x08	; 8
 2c2:	e1 f0       	breq	.+56     	; 0x2fc <MOVE_Tick+0x54>
 2c4:	86 30       	cpi	r24, 0x06	; 6
 2c6:	f1 f4       	brne	.+60     	; 0x304 <MOVE_Tick+0x5c>
 2c8:	0e c0       	rjmp	.+28     	; 0x2e6 <MOVE_Tick+0x3e>
		case INIT:
			
			srand(time(0));
 2ca:	80 e0       	ldi	r24, 0x00	; 0
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	05 df       	rcall	.-502    	; 0xda <time>
 2d0:	cb 01       	movw	r24, r22
 2d2:	e8 d5       	rcall	.+3024   	; 0xea4 <srand>
			//char where = "";
			PORTC = 0x11;
 2d4:	81 e1       	ldi	r24, 0x11	; 17
 2d6:	88 b9       	out	0x08, r24	; 8
			break;
 2d8:	15 c0       	rjmp	.+42     	; 0x304 <MOVE_Tick+0x5c>
		case check:  ;
			
			break;
		case left:  // turn left
			//where = "left";
			PORTC = 0x53;
 2da:	83 e5       	ldi	r24, 0x53	; 83
 2dc:	88 b9       	out	0x08, r24	; 8
			break;
 2de:	12 c0       	rjmp	.+36     	; 0x304 <MOVE_Tick+0x5c>
		case right: // turn right
			//where = "right;"
			PORTC = 0x35;
 2e0:	85 e3       	ldi	r24, 0x35	; 53
 2e2:	88 b9       	out	0x08, r24	; 8
			break;
 2e4:	0f c0       	rjmp	.+30     	; 0x304 <MOVE_Tick+0x5c>
		case turnAround: // turn around
			//where = "back";
			break;
		case forward: // move forward
			PORTC = 0x33;
 2e6:	83 e3       	ldi	r24, 0x33	; 51
 2e8:	88 b9       	out	0x08, r24	; 8
			vTaskDelay(200);
 2ea:	88 ec       	ldi	r24, 0xC8	; 200
 2ec:	90 e0       	ldi	r25, 0x00	; 0
 2ee:	a3 d4       	rcall	.+2374   	; 0xc36 <vTaskDelay>
			break;
 2f0:	09 c0       	rjmp	.+18     	; 0x304 <MOVE_Tick+0x5c>
		case turnWait:
			PORTC = 0x00;
 2f2:	18 b8       	out	0x08, r1	; 8
			vTaskDelay(200);
 2f4:	88 ec       	ldi	r24, 0xC8	; 200
 2f6:	90 e0       	ldi	r25, 0x00	; 0
 2f8:	9e d4       	rcall	.+2364   	; 0xc36 <vTaskDelay>
			break;
 2fa:	04 c0       	rjmp	.+8      	; 0x304 <MOVE_Tick+0x5c>
		case forwardWait:
			PORTC = 0x00;	
 2fc:	18 b8       	out	0x08, r1	; 8
			vTaskDelay(200);
 2fe:	88 ec       	ldi	r24, 0xC8	; 200
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	99 d4       	rcall	.+2354   	; 0xc36 <vTaskDelay>
			break;
		//trackData = setData;
	}
	//Transitions
	switch(moveMouse){
 304:	e0 91 5c 07 	lds	r30, 0x075C	; 0x80075c <moveMouse>
 308:	8e 2f       	mov	r24, r30
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	89 30       	cpi	r24, 0x09	; 9
 30e:	91 05       	cpc	r25, r1
 310:	08 f0       	brcs	.+2      	; 0x314 <MOVE_Tick+0x6c>
 312:	40 c0       	rjmp	.+128    	; 0x394 <MOVE_Tick+0xec>
 314:	fc 01       	movw	r30, r24
 316:	ea 5b       	subi	r30, 0xBA	; 186
 318:	ff 4f       	sbci	r31, 0xFF	; 255
 31a:	5d c5       	rjmp	.+2746   	; 0xdd6 <__tablejump2__>
		case INIT:
			//moveMouse = waitStart;
			moveMouse = forward;
 31c:	86 e0       	ldi	r24, 0x06	; 6
 31e:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			break;
 322:	08 95       	ret
		case waitStart:
			//moveMouse = check;
			moveMouse = forward;
 324:	86 e0       	ldi	r24, 0x06	; 6
 326:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			break;
 32a:	08 95       	ret
		case check: ;
			int adcL = adc_read(0);		// read adc value at PA0
 32c:	80 e0       	ldi	r24, 0x00	; 0
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	a6 df       	rcall	.-180    	; 0x27e <adc_read>
			int adcR = adc_read(1);		// read adc value at PA1
 332:	81 e0       	ldi	r24, 0x01	; 1
 334:	90 e0       	ldi	r25, 0x00	; 0
 336:	a3 df       	rcall	.-186    	; 0x27e <adc_read>
			int adcF = adc_read(2);		// read adc value at PA2
 338:	82 e0       	ldi	r24, 0x02	; 2
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	a0 df       	rcall	.-192    	; 0x27e <adc_read>
			
			
		
		
		
			int r = rand()%3;
 33e:	af d5       	rcall	.+2910   	; 0xe9e <rand>
 340:	63 e0       	ldi	r22, 0x03	; 3
 342:	70 e0       	ldi	r23, 0x00	; 0
 344:	35 d5       	rcall	.+2666   	; 0xdb0 <__divmodhi4>
			if(r == 0){
 346:	00 97       	sbiw	r24, 0x00	; 0
 348:	21 f4       	brne	.+8      	; 0x352 <MOVE_Tick+0xaa>
				moveMouse = left;
 34a:	83 e0       	ldi	r24, 0x03	; 3
 34c:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
 350:	08 95       	ret
			}
			else if(r == 1){
 352:	01 97       	sbiw	r24, 0x01	; 1
 354:	21 f4       	brne	.+8      	; 0x35e <MOVE_Tick+0xb6>
				moveMouse = right;
 356:	84 e0       	ldi	r24, 0x04	; 4
 358:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
 35c:	08 95       	ret
			}
			else{
				moveMouse = forward;
 35e:	86 e0       	ldi	r24, 0x06	; 6
 360:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
 364:	08 95       	ret
			}
			break;
		case left:
			moveMouse = turnWait;
 366:	87 e0       	ldi	r24, 0x07	; 7
 368:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			//moveMouse = right;
			break;
 36c:	08 95       	ret
		case right:
			moveMouse = turnWait;
 36e:	87 e0       	ldi	r24, 0x07	; 7
 370:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			break;
 374:	08 95       	ret
		case turnAround:
			moveMouse = turnWait;
 376:	87 e0       	ldi	r24, 0x07	; 7
 378:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			break;
 37c:	08 95       	ret
		case turnWait:
			moveMouse = forward;
 37e:	86 e0       	ldi	r24, 0x06	; 6
 380:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			break;
 384:	08 95       	ret
		case forward:
			moveMouse = forwardWait;
 386:	88 e0       	ldi	r24, 0x08	; 8
 388:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
			//moveMouse = left;
			break;
 38c:	08 95       	ret
		case forwardWait:
			moveMouse = check;
 38e:	82 e0       	ldi	r24, 0x02	; 2
 390:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <moveMouse>
 394:	08 95       	ret

00000396 <MoveSecTask>:
	
	return (ADC);
}

void MOVE_Init(){
	moveMouse = INIT;
 396:	10 92 5c 07 	sts	0x075C, r1	; 0x80075c <moveMouse>
void MoveSecTask()
{
	MOVE_Init();
   for(;;) 
   { 	
	MOVE_Tick();
 39a:	86 df       	rcall	.-244    	; 0x2a8 <MOVE_Tick>
	vTaskDelay(200); 
 39c:	88 ec       	ldi	r24, 0xC8	; 200
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	4a d4       	rcall	.+2196   	; 0xc36 <vTaskDelay>
   } 
 3a2:	fb cf       	rjmp	.-10     	; 0x39a <MoveSecTask+0x4>

000003a4 <EMIT_Tick>:
	}	
}
*/

void EMIT_Tick(){
	switch(emitLight){
 3a4:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <emitLight>
 3a8:	81 30       	cpi	r24, 0x01	; 1
 3aa:	41 f0       	breq	.+16     	; 0x3bc <EMIT_Tick+0x18>
 3ac:	18 f0       	brcs	.+6      	; 0x3b4 <EMIT_Tick+0x10>
 3ae:	82 30       	cpi	r24, 0x02	; 2
 3b0:	61 f0       	breq	.+24     	; 0x3ca <EMIT_Tick+0x26>
 3b2:	08 95       	ret
		case INITEmit:
			emitLight = on;
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <emitLight>
			break;
 3ba:	08 95       	ret
		case on:
			PORTA = (PORTA & 0x8F) | 0x70;
 3bc:	82 b1       	in	r24, 0x02	; 2
 3be:	80 67       	ori	r24, 0x70	; 112
 3c0:	82 b9       	out	0x02, r24	; 2
			emitLight = off;
 3c2:	82 e0       	ldi	r24, 0x02	; 2
 3c4:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <emitLight>
			break;
 3c8:	08 95       	ret
		case off:
			PORTA  = (PORTA & 0x8F) | 0x00;
 3ca:	82 b1       	in	r24, 0x02	; 2
 3cc:	8f 78       	andi	r24, 0x8F	; 143
 3ce:	82 b9       	out	0x02, r24	; 2
			emitLight = on;
 3d0:	81 e0       	ldi	r24, 0x01	; 1
 3d2:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <emitLight>
 3d6:	08 95       	ret

000003d8 <EmitSecTask>:
/*
void TRACK_Init(){
	trackData = INITTrack;
}*/
void EMIT_Init(){
	emitLight = INITEmit;
 3d8:	10 92 5d 07 	sts	0x075D, r1	; 0x80075d <emitLight>
}

void EmitSecTask(){
	EMIT_Init();
	for(;;){
		EMIT_Tick();
 3dc:	e3 df       	rcall	.-58     	; 0x3a4 <EMIT_Tick>
		vTaskDelay(100);
 3de:	84 e6       	ldi	r24, 0x64	; 100
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	29 d4       	rcall	.+2130   	; 0xc36 <vTaskDelay>
	}
 3e4:	fb cf       	rjmp	.-10     	; 0x3dc <EmitSecTask+0x4>

000003e6 <StartSecPulse>:
		vTaskDelay(100);	
	}
}*/

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
 3e6:	af 92       	push	r10
 3e8:	bf 92       	push	r11
 3ea:	cf 92       	push	r12
 3ec:	df 92       	push	r13
 3ee:	ef 92       	push	r14
 3f0:	ff 92       	push	r15
 3f2:	0f 93       	push	r16
 3f4:	cf 93       	push	r28
	xTaskCreate(MoveSecTask, (signed portCHAR *)"MoveSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 3f6:	a1 2c       	mov	r10, r1
 3f8:	b1 2c       	mov	r11, r1
 3fa:	c1 2c       	mov	r12, r1
 3fc:	d1 2c       	mov	r13, r1
 3fe:	e1 2c       	mov	r14, r1
 400:	f1 2c       	mov	r15, r1
 402:	08 2f       	mov	r16, r24
 404:	20 e0       	ldi	r18, 0x00	; 0
 406:	30 e0       	ldi	r19, 0x00	; 0
 408:	45 e5       	ldi	r20, 0x55	; 85
 40a:	50 e0       	ldi	r21, 0x00	; 0
 40c:	66 e0       	ldi	r22, 0x06	; 6
 40e:	71 e0       	ldi	r23, 0x01	; 1
 410:	8b ec       	ldi	r24, 0xCB	; 203
 412:	91 e0       	ldi	r25, 0x01	; 1
 414:	ac d1       	rcall	.+856    	; 0x76e <xTaskGenericCreate>
	//xTaskCreate(TrackSecTask, (signed portCHAR *)"TrackSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
	xTaskCreate(EmitSecTask, (signed portCHAR *)"EmitSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 416:	20 e0       	ldi	r18, 0x00	; 0
 418:	30 e0       	ldi	r19, 0x00	; 0
 41a:	45 e5       	ldi	r20, 0x55	; 85
 41c:	50 e0       	ldi	r21, 0x00	; 0
 41e:	62 e1       	ldi	r22, 0x12	; 18
 420:	71 e0       	ldi	r23, 0x01	; 1
 422:	8c ee       	ldi	r24, 0xEC	; 236
 424:	91 e0       	ldi	r25, 0x01	; 1
 426:	a3 d1       	rcall	.+838    	; 0x76e <xTaskGenericCreate>
}	
 428:	cf 91       	pop	r28
 42a:	0f 91       	pop	r16
 42c:	ff 90       	pop	r15
 42e:	ef 90       	pop	r14
 430:	df 90       	pop	r13
 432:	cf 90       	pop	r12
 434:	bf 90       	pop	r11
 436:	af 90       	pop	r10
 438:	08 95       	ret

0000043a <main>:
 
int main(void) 
{ 
   DDRA = 0xF0; PORTA=0xFF;
 43a:	80 ef       	ldi	r24, 0xF0	; 240
 43c:	81 b9       	out	0x01, r24	; 1
 43e:	8f ef       	ldi	r24, 0xFF	; 255
 440:	82 b9       	out	0x02, r24	; 2
   DDRC = 0xFF; 
 442:	87 b9       	out	0x07, r24	; 7
   DDRD = 0xFF;
 444:	8a b9       	out	0x0a, r24	; 10
   //Start Tasks  
   StartSecPulse(1);
 446:	81 e0       	ldi	r24, 0x01	; 1
 448:	ce df       	rcall	.-100    	; 0x3e6 <StartSecPulse>
    //RunSchedular 
   vTaskStartScheduler(); 
 44a:	84 d2       	rcall	.+1288   	; 0x954 <vTaskStartScheduler>
 
   return 0; 
 44c:	80 e0       	ldi	r24, 0x00	; 0
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	08 95       	ret

00000452 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 452:	31 e1       	ldi	r19, 0x11	; 17
 454:	fc 01       	movw	r30, r24
 456:	30 83       	st	Z, r19
 458:	31 97       	sbiw	r30, 0x01	; 1
 45a:	22 e2       	ldi	r18, 0x22	; 34
 45c:	20 83       	st	Z, r18
 45e:	31 97       	sbiw	r30, 0x01	; 1
 460:	a3 e3       	ldi	r26, 0x33	; 51
 462:	a0 83       	st	Z, r26
 464:	31 97       	sbiw	r30, 0x01	; 1
 466:	60 83       	st	Z, r22
 468:	31 97       	sbiw	r30, 0x01	; 1
 46a:	70 83       	st	Z, r23
 46c:	31 97       	sbiw	r30, 0x01	; 1
 46e:	10 82       	st	Z, r1
 470:	31 97       	sbiw	r30, 0x01	; 1
 472:	60 e8       	ldi	r22, 0x80	; 128
 474:	60 83       	st	Z, r22
 476:	31 97       	sbiw	r30, 0x01	; 1
 478:	10 82       	st	Z, r1
 47a:	31 97       	sbiw	r30, 0x01	; 1
 47c:	62 e0       	ldi	r22, 0x02	; 2
 47e:	60 83       	st	Z, r22
 480:	31 97       	sbiw	r30, 0x01	; 1
 482:	63 e0       	ldi	r22, 0x03	; 3
 484:	60 83       	st	Z, r22
 486:	31 97       	sbiw	r30, 0x01	; 1
 488:	64 e0       	ldi	r22, 0x04	; 4
 48a:	60 83       	st	Z, r22
 48c:	31 97       	sbiw	r30, 0x01	; 1
 48e:	65 e0       	ldi	r22, 0x05	; 5
 490:	60 83       	st	Z, r22
 492:	31 97       	sbiw	r30, 0x01	; 1
 494:	66 e0       	ldi	r22, 0x06	; 6
 496:	60 83       	st	Z, r22
 498:	31 97       	sbiw	r30, 0x01	; 1
 49a:	67 e0       	ldi	r22, 0x07	; 7
 49c:	60 83       	st	Z, r22
 49e:	31 97       	sbiw	r30, 0x01	; 1
 4a0:	68 e0       	ldi	r22, 0x08	; 8
 4a2:	60 83       	st	Z, r22
 4a4:	31 97       	sbiw	r30, 0x01	; 1
 4a6:	69 e0       	ldi	r22, 0x09	; 9
 4a8:	60 83       	st	Z, r22
 4aa:	31 97       	sbiw	r30, 0x01	; 1
 4ac:	60 e1       	ldi	r22, 0x10	; 16
 4ae:	60 83       	st	Z, r22
 4b0:	31 97       	sbiw	r30, 0x01	; 1
 4b2:	30 83       	st	Z, r19
 4b4:	31 97       	sbiw	r30, 0x01	; 1
 4b6:	32 e1       	ldi	r19, 0x12	; 18
 4b8:	30 83       	st	Z, r19
 4ba:	31 97       	sbiw	r30, 0x01	; 1
 4bc:	33 e1       	ldi	r19, 0x13	; 19
 4be:	30 83       	st	Z, r19
 4c0:	31 97       	sbiw	r30, 0x01	; 1
 4c2:	34 e1       	ldi	r19, 0x14	; 20
 4c4:	30 83       	st	Z, r19
 4c6:	31 97       	sbiw	r30, 0x01	; 1
 4c8:	35 e1       	ldi	r19, 0x15	; 21
 4ca:	30 83       	st	Z, r19
 4cc:	31 97       	sbiw	r30, 0x01	; 1
 4ce:	36 e1       	ldi	r19, 0x16	; 22
 4d0:	30 83       	st	Z, r19
 4d2:	31 97       	sbiw	r30, 0x01	; 1
 4d4:	37 e1       	ldi	r19, 0x17	; 23
 4d6:	30 83       	st	Z, r19
 4d8:	31 97       	sbiw	r30, 0x01	; 1
 4da:	38 e1       	ldi	r19, 0x18	; 24
 4dc:	30 83       	st	Z, r19
 4de:	31 97       	sbiw	r30, 0x01	; 1
 4e0:	39 e1       	ldi	r19, 0x19	; 25
 4e2:	30 83       	st	Z, r19
 4e4:	31 97       	sbiw	r30, 0x01	; 1
 4e6:	30 e2       	ldi	r19, 0x20	; 32
 4e8:	30 83       	st	Z, r19
 4ea:	31 97       	sbiw	r30, 0x01	; 1
 4ec:	31 e2       	ldi	r19, 0x21	; 33
 4ee:	30 83       	st	Z, r19
 4f0:	31 97       	sbiw	r30, 0x01	; 1
 4f2:	20 83       	st	Z, r18
 4f4:	31 97       	sbiw	r30, 0x01	; 1
 4f6:	23 e2       	ldi	r18, 0x23	; 35
 4f8:	20 83       	st	Z, r18
 4fa:	31 97       	sbiw	r30, 0x01	; 1
 4fc:	40 83       	st	Z, r20
 4fe:	31 97       	sbiw	r30, 0x01	; 1
 500:	50 83       	st	Z, r21
 502:	31 97       	sbiw	r30, 0x01	; 1
 504:	26 e2       	ldi	r18, 0x26	; 38
 506:	20 83       	st	Z, r18
 508:	31 97       	sbiw	r30, 0x01	; 1
 50a:	27 e2       	ldi	r18, 0x27	; 39
 50c:	20 83       	st	Z, r18
 50e:	31 97       	sbiw	r30, 0x01	; 1
 510:	28 e2       	ldi	r18, 0x28	; 40
 512:	20 83       	st	Z, r18
 514:	31 97       	sbiw	r30, 0x01	; 1
 516:	29 e2       	ldi	r18, 0x29	; 41
 518:	20 83       	st	Z, r18
 51a:	31 97       	sbiw	r30, 0x01	; 1
 51c:	20 e3       	ldi	r18, 0x30	; 48
 51e:	20 83       	st	Z, r18
 520:	31 97       	sbiw	r30, 0x01	; 1
 522:	21 e3       	ldi	r18, 0x31	; 49
 524:	20 83       	st	Z, r18
 526:	86 97       	sbiw	r24, 0x26	; 38
 528:	08 95       	ret

0000052a <xPortStartScheduler>:
 52a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 52e:	8c e7       	ldi	r24, 0x7C	; 124
 530:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 534:	8b e0       	ldi	r24, 0x0B	; 11
 536:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 53a:	ef e6       	ldi	r30, 0x6F	; 111
 53c:	f0 e0       	ldi	r31, 0x00	; 0
 53e:	80 81       	ld	r24, Z
 540:	82 60       	ori	r24, 0x02	; 2
 542:	80 83       	st	Z, r24
 544:	a0 91 5a 07 	lds	r26, 0x075A	; 0x80075a <pxCurrentTCB>
 548:	b0 91 5b 07 	lds	r27, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 54c:	cd 91       	ld	r28, X+
 54e:	cd bf       	out	0x3d, r28	; 61
 550:	dd 91       	ld	r29, X+
 552:	de bf       	out	0x3e, r29	; 62
 554:	ff 91       	pop	r31
 556:	ef 91       	pop	r30
 558:	df 91       	pop	r29
 55a:	cf 91       	pop	r28
 55c:	bf 91       	pop	r27
 55e:	af 91       	pop	r26
 560:	9f 91       	pop	r25
 562:	8f 91       	pop	r24
 564:	7f 91       	pop	r23
 566:	6f 91       	pop	r22
 568:	5f 91       	pop	r21
 56a:	4f 91       	pop	r20
 56c:	3f 91       	pop	r19
 56e:	2f 91       	pop	r18
 570:	1f 91       	pop	r17
 572:	0f 91       	pop	r16
 574:	ff 90       	pop	r15
 576:	ef 90       	pop	r14
 578:	df 90       	pop	r13
 57a:	cf 90       	pop	r12
 57c:	bf 90       	pop	r11
 57e:	af 90       	pop	r10
 580:	9f 90       	pop	r9
 582:	8f 90       	pop	r8
 584:	7f 90       	pop	r7
 586:	6f 90       	pop	r6
 588:	5f 90       	pop	r5
 58a:	4f 90       	pop	r4
 58c:	3f 90       	pop	r3
 58e:	2f 90       	pop	r2
 590:	1f 90       	pop	r1
 592:	0f 90       	pop	r0
 594:	0f be       	out	0x3f, r0	; 63
 596:	0f 90       	pop	r0
 598:	08 95       	ret
 59a:	81 e0       	ldi	r24, 0x01	; 1
 59c:	08 95       	ret

0000059e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 59e:	0f 92       	push	r0
 5a0:	0f b6       	in	r0, 0x3f	; 63
 5a2:	f8 94       	cli
 5a4:	0f 92       	push	r0
 5a6:	1f 92       	push	r1
 5a8:	11 24       	eor	r1, r1
 5aa:	2f 92       	push	r2
 5ac:	3f 92       	push	r3
 5ae:	4f 92       	push	r4
 5b0:	5f 92       	push	r5
 5b2:	6f 92       	push	r6
 5b4:	7f 92       	push	r7
 5b6:	8f 92       	push	r8
 5b8:	9f 92       	push	r9
 5ba:	af 92       	push	r10
 5bc:	bf 92       	push	r11
 5be:	cf 92       	push	r12
 5c0:	df 92       	push	r13
 5c2:	ef 92       	push	r14
 5c4:	ff 92       	push	r15
 5c6:	0f 93       	push	r16
 5c8:	1f 93       	push	r17
 5ca:	2f 93       	push	r18
 5cc:	3f 93       	push	r19
 5ce:	4f 93       	push	r20
 5d0:	5f 93       	push	r21
 5d2:	6f 93       	push	r22
 5d4:	7f 93       	push	r23
 5d6:	8f 93       	push	r24
 5d8:	9f 93       	push	r25
 5da:	af 93       	push	r26
 5dc:	bf 93       	push	r27
 5de:	cf 93       	push	r28
 5e0:	df 93       	push	r29
 5e2:	ef 93       	push	r30
 5e4:	ff 93       	push	r31
 5e6:	a0 91 5a 07 	lds	r26, 0x075A	; 0x80075a <pxCurrentTCB>
 5ea:	b0 91 5b 07 	lds	r27, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 5ee:	0d b6       	in	r0, 0x3d	; 61
 5f0:	0d 92       	st	X+, r0
 5f2:	0e b6       	in	r0, 0x3e	; 62
 5f4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 5f6:	70 d3       	rcall	.+1760   	; 0xcd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 5f8:	a0 91 5a 07 	lds	r26, 0x075A	; 0x80075a <pxCurrentTCB>
 5fc:	b0 91 5b 07 	lds	r27, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 600:	cd 91       	ld	r28, X+
 602:	cd bf       	out	0x3d, r28	; 61
 604:	dd 91       	ld	r29, X+
 606:	de bf       	out	0x3e, r29	; 62
 608:	ff 91       	pop	r31
 60a:	ef 91       	pop	r30
 60c:	df 91       	pop	r29
 60e:	cf 91       	pop	r28
 610:	bf 91       	pop	r27
 612:	af 91       	pop	r26
 614:	9f 91       	pop	r25
 616:	8f 91       	pop	r24
 618:	7f 91       	pop	r23
 61a:	6f 91       	pop	r22
 61c:	5f 91       	pop	r21
 61e:	4f 91       	pop	r20
 620:	3f 91       	pop	r19
 622:	2f 91       	pop	r18
 624:	1f 91       	pop	r17
 626:	0f 91       	pop	r16
 628:	ff 90       	pop	r15
 62a:	ef 90       	pop	r14
 62c:	df 90       	pop	r13
 62e:	cf 90       	pop	r12
 630:	bf 90       	pop	r11
 632:	af 90       	pop	r10
 634:	9f 90       	pop	r9
 636:	8f 90       	pop	r8
 638:	7f 90       	pop	r7
 63a:	6f 90       	pop	r6
 63c:	5f 90       	pop	r5
 63e:	4f 90       	pop	r4
 640:	3f 90       	pop	r3
 642:	2f 90       	pop	r2
 644:	1f 90       	pop	r1
 646:	0f 90       	pop	r0
 648:	0f be       	out	0x3f, r0	; 63
 64a:	0f 90       	pop	r0

	asm volatile ( "ret" );
 64c:	08 95       	ret

0000064e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 64e:	0f 92       	push	r0
 650:	0f b6       	in	r0, 0x3f	; 63
 652:	f8 94       	cli
 654:	0f 92       	push	r0
 656:	1f 92       	push	r1
 658:	11 24       	eor	r1, r1
 65a:	2f 92       	push	r2
 65c:	3f 92       	push	r3
 65e:	4f 92       	push	r4
 660:	5f 92       	push	r5
 662:	6f 92       	push	r6
 664:	7f 92       	push	r7
 666:	8f 92       	push	r8
 668:	9f 92       	push	r9
 66a:	af 92       	push	r10
 66c:	bf 92       	push	r11
 66e:	cf 92       	push	r12
 670:	df 92       	push	r13
 672:	ef 92       	push	r14
 674:	ff 92       	push	r15
 676:	0f 93       	push	r16
 678:	1f 93       	push	r17
 67a:	2f 93       	push	r18
 67c:	3f 93       	push	r19
 67e:	4f 93       	push	r20
 680:	5f 93       	push	r21
 682:	6f 93       	push	r22
 684:	7f 93       	push	r23
 686:	8f 93       	push	r24
 688:	9f 93       	push	r25
 68a:	af 93       	push	r26
 68c:	bf 93       	push	r27
 68e:	cf 93       	push	r28
 690:	df 93       	push	r29
 692:	ef 93       	push	r30
 694:	ff 93       	push	r31
 696:	a0 91 5a 07 	lds	r26, 0x075A	; 0x80075a <pxCurrentTCB>
 69a:	b0 91 5b 07 	lds	r27, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 69e:	0d b6       	in	r0, 0x3d	; 61
 6a0:	0d 92       	st	X+, r0
 6a2:	0e b6       	in	r0, 0x3e	; 62
 6a4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 6a6:	85 d1       	rcall	.+778    	; 0x9b2 <vTaskIncrementTick>
	vTaskSwitchContext();
 6a8:	17 d3       	rcall	.+1582   	; 0xcd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 6aa:	a0 91 5a 07 	lds	r26, 0x075A	; 0x80075a <pxCurrentTCB>
 6ae:	b0 91 5b 07 	lds	r27, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 6b2:	cd 91       	ld	r28, X+
 6b4:	cd bf       	out	0x3d, r28	; 61
 6b6:	dd 91       	ld	r29, X+
 6b8:	de bf       	out	0x3e, r29	; 62
 6ba:	ff 91       	pop	r31
 6bc:	ef 91       	pop	r30
 6be:	df 91       	pop	r29
 6c0:	cf 91       	pop	r28
 6c2:	bf 91       	pop	r27
 6c4:	af 91       	pop	r26
 6c6:	9f 91       	pop	r25
 6c8:	8f 91       	pop	r24
 6ca:	7f 91       	pop	r23
 6cc:	6f 91       	pop	r22
 6ce:	5f 91       	pop	r21
 6d0:	4f 91       	pop	r20
 6d2:	3f 91       	pop	r19
 6d4:	2f 91       	pop	r18
 6d6:	1f 91       	pop	r17
 6d8:	0f 91       	pop	r16
 6da:	ff 90       	pop	r15
 6dc:	ef 90       	pop	r14
 6de:	df 90       	pop	r13
 6e0:	cf 90       	pop	r12
 6e2:	bf 90       	pop	r11
 6e4:	af 90       	pop	r10
 6e6:	9f 90       	pop	r9
 6e8:	8f 90       	pop	r8
 6ea:	7f 90       	pop	r7
 6ec:	6f 90       	pop	r6
 6ee:	5f 90       	pop	r5
 6f0:	4f 90       	pop	r4
 6f2:	3f 90       	pop	r3
 6f4:	2f 90       	pop	r2
 6f6:	1f 90       	pop	r1
 6f8:	0f 90       	pop	r0
 6fa:	0f be       	out	0x3f, r0	; 63
 6fc:	0f 90       	pop	r0

	asm volatile ( "ret" );
 6fe:	08 95       	ret

00000700 <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 700:	a6 df       	rcall	.-180    	; 0x64e <vPortYieldFromTick>
		asm volatile ( "reti" );
 702:	18 95       	reti

00000704 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 704:	cf 93       	push	r28
 706:	df 93       	push	r29
 708:	ec 01       	movw	r28, r24
 70a:	e0 91 5a 07 	lds	r30, 0x075A	; 0x80075a <pxCurrentTCB>
 70e:	f0 91 5b 07 	lds	r31, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 712:	93 83       	std	Z+3, r25	; 0x03
 714:	82 83       	std	Z+2, r24	; 0x02
 716:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 71a:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 71e:	c8 17       	cp	r28, r24
 720:	d9 07       	cpc	r29, r25
 722:	60 f4       	brcc	.+24     	; 0x73c <prvAddCurrentTaskToDelayedList+0x38>
 724:	60 91 5a 07 	lds	r22, 0x075A	; 0x80075a <pxCurrentTCB>
 728:	70 91 5b 07 	lds	r23, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 72c:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <pxOverflowDelayedTaskList>
 730:	90 91 21 07 	lds	r25, 0x0721	; 0x800721 <pxOverflowDelayedTaskList+0x1>
 734:	6e 5f       	subi	r22, 0xFE	; 254
 736:	7f 4f       	sbci	r23, 0xFF	; 255
 738:	41 dd       	rcall	.-1406   	; 0x1bc <vListInsert>
 73a:	16 c0       	rjmp	.+44     	; 0x768 <prvAddCurrentTaskToDelayedList+0x64>
 73c:	60 91 5a 07 	lds	r22, 0x075A	; 0x80075a <pxCurrentTCB>
 740:	70 91 5b 07 	lds	r23, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 744:	80 91 22 07 	lds	r24, 0x0722	; 0x800722 <pxDelayedTaskList>
 748:	90 91 23 07 	lds	r25, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 74c:	6e 5f       	subi	r22, 0xFE	; 254
 74e:	7f 4f       	sbci	r23, 0xFF	; 255
 750:	35 dd       	rcall	.-1430   	; 0x1bc <vListInsert>
 752:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <xNextTaskUnblockTime>
 756:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <xNextTaskUnblockTime+0x1>
 75a:	c8 17       	cp	r28, r24
 75c:	d9 07       	cpc	r29, r25
 75e:	20 f4       	brcc	.+8      	; 0x768 <prvAddCurrentTaskToDelayedList+0x64>
 760:	d0 93 05 01 	sts	0x0105, r29	; 0x800105 <xNextTaskUnblockTime+0x1>
 764:	c0 93 04 01 	sts	0x0104, r28	; 0x800104 <xNextTaskUnblockTime>
 768:	df 91       	pop	r29
 76a:	cf 91       	pop	r28
 76c:	08 95       	ret

0000076e <xTaskGenericCreate>:
 76e:	4f 92       	push	r4
 770:	5f 92       	push	r5
 772:	6f 92       	push	r6
 774:	7f 92       	push	r7
 776:	8f 92       	push	r8
 778:	9f 92       	push	r9
 77a:	af 92       	push	r10
 77c:	bf 92       	push	r11
 77e:	cf 92       	push	r12
 780:	df 92       	push	r13
 782:	ef 92       	push	r14
 784:	ff 92       	push	r15
 786:	0f 93       	push	r16
 788:	1f 93       	push	r17
 78a:	cf 93       	push	r28
 78c:	df 93       	push	r29
 78e:	5c 01       	movw	r10, r24
 790:	4b 01       	movw	r8, r22
 792:	3a 01       	movw	r6, r20
 794:	29 01       	movw	r4, r18
 796:	81 e2       	ldi	r24, 0x21	; 33
 798:	90 e0       	ldi	r25, 0x00	; 0
 79a:	b2 dc       	rcall	.-1692   	; 0x100 <pvPortMalloc>
 79c:	ec 01       	movw	r28, r24
 79e:	89 2b       	or	r24, r25
 7a0:	09 f4       	brne	.+2      	; 0x7a4 <xTaskGenericCreate+0x36>
 7a2:	c6 c0       	rjmp	.+396    	; 0x930 <xTaskGenericCreate+0x1c2>
 7a4:	c1 14       	cp	r12, r1
 7a6:	d1 04       	cpc	r13, r1
 7a8:	09 f0       	breq	.+2      	; 0x7ac <xTaskGenericCreate+0x3e>
 7aa:	be c0       	rjmp	.+380    	; 0x928 <xTaskGenericCreate+0x1ba>
 7ac:	c3 01       	movw	r24, r6
 7ae:	a8 dc       	rcall	.-1712   	; 0x100 <pvPortMalloc>
 7b0:	98 8f       	std	Y+24, r25	; 0x18
 7b2:	8f 8b       	std	Y+23, r24	; 0x17
 7b4:	00 97       	sbiw	r24, 0x00	; 0
 7b6:	19 f4       	brne	.+6      	; 0x7be <xTaskGenericCreate+0x50>
 7b8:	ce 01       	movw	r24, r28
 7ba:	c6 dc       	rcall	.-1652   	; 0x148 <vPortFree>
 7bc:	b9 c0       	rjmp	.+370    	; 0x930 <xTaskGenericCreate+0x1c2>
 7be:	a3 01       	movw	r20, r6
 7c0:	65 ea       	ldi	r22, 0xA5	; 165
 7c2:	70 e0       	ldi	r23, 0x00	; 0
 7c4:	7a d3       	rcall	.+1780   	; 0xeba <memset>
 7c6:	93 01       	movw	r18, r6
 7c8:	21 50       	subi	r18, 0x01	; 1
 7ca:	31 09       	sbc	r19, r1
 7cc:	8f 89       	ldd	r24, Y+23	; 0x17
 7ce:	98 8d       	ldd	r25, Y+24	; 0x18
 7d0:	3c 01       	movw	r6, r24
 7d2:	62 0e       	add	r6, r18
 7d4:	73 1e       	adc	r7, r19
 7d6:	48 e0       	ldi	r20, 0x08	; 8
 7d8:	50 e0       	ldi	r21, 0x00	; 0
 7da:	b4 01       	movw	r22, r8
 7dc:	ce 01       	movw	r24, r28
 7de:	49 96       	adiw	r24, 0x19	; 25
 7e0:	73 d3       	rcall	.+1766   	; 0xec8 <strncpy>
 7e2:	18 a2       	std	Y+32, r1	; 0x20
 7e4:	10 2f       	mov	r17, r16
 7e6:	04 30       	cpi	r16, 0x04	; 4
 7e8:	08 f0       	brcs	.+2      	; 0x7ec <xTaskGenericCreate+0x7e>
 7ea:	13 e0       	ldi	r17, 0x03	; 3
 7ec:	1e 8b       	std	Y+22, r17	; 0x16
 7ee:	6e 01       	movw	r12, r28
 7f0:	82 e0       	ldi	r24, 0x02	; 2
 7f2:	c8 0e       	add	r12, r24
 7f4:	d1 1c       	adc	r13, r1
 7f6:	c6 01       	movw	r24, r12
 7f8:	b6 dc       	rcall	.-1684   	; 0x166 <vListInitialiseItem>
 7fa:	ce 01       	movw	r24, r28
 7fc:	0c 96       	adiw	r24, 0x0c	; 12
 7fe:	b3 dc       	rcall	.-1690   	; 0x166 <vListInitialiseItem>
 800:	d9 87       	std	Y+9, r29	; 0x09
 802:	c8 87       	std	Y+8, r28	; 0x08
 804:	84 e0       	ldi	r24, 0x04	; 4
 806:	90 e0       	ldi	r25, 0x00	; 0
 808:	81 1b       	sub	r24, r17
 80a:	91 09       	sbc	r25, r1
 80c:	9d 87       	std	Y+13, r25	; 0x0d
 80e:	8c 87       	std	Y+12, r24	; 0x0c
 810:	db 8b       	std	Y+19, r29	; 0x13
 812:	ca 8b       	std	Y+18, r28	; 0x12
 814:	a2 01       	movw	r20, r4
 816:	b5 01       	movw	r22, r10
 818:	c3 01       	movw	r24, r6
 81a:	1b de       	rcall	.-970    	; 0x452 <pxPortInitialiseStack>
 81c:	99 83       	std	Y+1, r25	; 0x01
 81e:	88 83       	st	Y, r24
 820:	e1 14       	cp	r14, r1
 822:	f1 04       	cpc	r15, r1
 824:	19 f0       	breq	.+6      	; 0x82c <xTaskGenericCreate+0xbe>
 826:	f7 01       	movw	r30, r14
 828:	d1 83       	std	Z+1, r29	; 0x01
 82a:	c0 83       	st	Z, r28
 82c:	0f b6       	in	r0, 0x3f	; 63
 82e:	f8 94       	cli
 830:	0f 92       	push	r0
 832:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 836:	8f 5f       	subi	r24, 0xFF	; 255
 838:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxCurrentNumberOfTasks>
 83c:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <pxCurrentTCB>
 840:	90 91 5b 07 	lds	r25, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 844:	89 2b       	or	r24, r25
 846:	69 f5       	brne	.+90     	; 0x8a2 <xTaskGenericCreate+0x134>
 848:	d0 93 5b 07 	sts	0x075B, r29	; 0x80075b <pxCurrentTCB+0x1>
 84c:	c0 93 5a 07 	sts	0x075A, r28	; 0x80075a <pxCurrentTCB>
 850:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 854:	81 30       	cpi	r24, 0x01	; 1
 856:	a1 f5       	brne	.+104    	; 0x8c0 <xTaskGenericCreate+0x152>
 858:	86 e3       	ldi	r24, 0x36	; 54
 85a:	97 e0       	ldi	r25, 0x07	; 7
 85c:	76 dc       	rcall	.-1812   	; 0x14a <vListInitialise>
 85e:	8f e3       	ldi	r24, 0x3F	; 63
 860:	97 e0       	ldi	r25, 0x07	; 7
 862:	73 dc       	rcall	.-1818   	; 0x14a <vListInitialise>
 864:	88 e4       	ldi	r24, 0x48	; 72
 866:	97 e0       	ldi	r25, 0x07	; 7
 868:	70 dc       	rcall	.-1824   	; 0x14a <vListInitialise>
 86a:	81 e5       	ldi	r24, 0x51	; 81
 86c:	97 e0       	ldi	r25, 0x07	; 7
 86e:	6d dc       	rcall	.-1830   	; 0x14a <vListInitialise>
 870:	8d e2       	ldi	r24, 0x2D	; 45
 872:	97 e0       	ldi	r25, 0x07	; 7
 874:	6a dc       	rcall	.-1836   	; 0x14a <vListInitialise>
 876:	84 e2       	ldi	r24, 0x24	; 36
 878:	97 e0       	ldi	r25, 0x07	; 7
 87a:	67 dc       	rcall	.-1842   	; 0x14a <vListInitialise>
 87c:	87 e1       	ldi	r24, 0x17	; 23
 87e:	97 e0       	ldi	r25, 0x07	; 7
 880:	64 dc       	rcall	.-1848   	; 0x14a <vListInitialise>
 882:	8e e0       	ldi	r24, 0x0E	; 14
 884:	97 e0       	ldi	r25, 0x07	; 7
 886:	61 dc       	rcall	.-1854   	; 0x14a <vListInitialise>
 888:	8d e2       	ldi	r24, 0x2D	; 45
 88a:	97 e0       	ldi	r25, 0x07	; 7
 88c:	90 93 23 07 	sts	0x0723, r25	; 0x800723 <pxDelayedTaskList+0x1>
 890:	80 93 22 07 	sts	0x0722, r24	; 0x800722 <pxDelayedTaskList>
 894:	84 e2       	ldi	r24, 0x24	; 36
 896:	97 e0       	ldi	r25, 0x07	; 7
 898:	90 93 21 07 	sts	0x0721, r25	; 0x800721 <pxOverflowDelayedTaskList+0x1>
 89c:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <pxOverflowDelayedTaskList>
 8a0:	0f c0       	rjmp	.+30     	; 0x8c0 <xTaskGenericCreate+0x152>
 8a2:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xSchedulerRunning>
 8a6:	81 11       	cpse	r24, r1
 8a8:	0b c0       	rjmp	.+22     	; 0x8c0 <xTaskGenericCreate+0x152>
 8aa:	e0 91 5a 07 	lds	r30, 0x075A	; 0x80075a <pxCurrentTCB>
 8ae:	f0 91 5b 07 	lds	r31, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 8b2:	86 89       	ldd	r24, Z+22	; 0x16
 8b4:	08 17       	cp	r16, r24
 8b6:	20 f0       	brcs	.+8      	; 0x8c0 <xTaskGenericCreate+0x152>
 8b8:	d0 93 5b 07 	sts	0x075B, r29	; 0x80075b <pxCurrentTCB+0x1>
 8bc:	c0 93 5a 07 	sts	0x075A, r28	; 0x80075a <pxCurrentTCB>
 8c0:	8e 89       	ldd	r24, Y+22	; 0x16
 8c2:	90 91 09 07 	lds	r25, 0x0709	; 0x800709 <uxTopUsedPriority>
 8c6:	98 17       	cp	r25, r24
 8c8:	10 f4       	brcc	.+4      	; 0x8ce <xTaskGenericCreate+0x160>
 8ca:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxTopUsedPriority>
 8ce:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTaskNumber>
 8d2:	9f 5f       	subi	r25, 0xFF	; 255
 8d4:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <uxTaskNumber>
 8d8:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
 8dc:	98 17       	cp	r25, r24
 8de:	10 f4       	brcc	.+4      	; 0x8e4 <xTaskGenericCreate+0x176>
 8e0:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
 8e4:	90 e0       	ldi	r25, 0x00	; 0
 8e6:	9c 01       	movw	r18, r24
 8e8:	22 0f       	add	r18, r18
 8ea:	33 1f       	adc	r19, r19
 8ec:	22 0f       	add	r18, r18
 8ee:	33 1f       	adc	r19, r19
 8f0:	22 0f       	add	r18, r18
 8f2:	33 1f       	adc	r19, r19
 8f4:	82 0f       	add	r24, r18
 8f6:	93 1f       	adc	r25, r19
 8f8:	b6 01       	movw	r22, r12
 8fa:	8a 5c       	subi	r24, 0xCA	; 202
 8fc:	98 4f       	sbci	r25, 0xF8	; 248
 8fe:	37 dc       	rcall	.-1938   	; 0x16e <vListInsertEnd>
 900:	0f 90       	pop	r0
 902:	0f be       	out	0x3f, r0	; 63
 904:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xSchedulerRunning>
 908:	88 23       	and	r24, r24
 90a:	51 f0       	breq	.+20     	; 0x920 <xTaskGenericCreate+0x1b2>
 90c:	e0 91 5a 07 	lds	r30, 0x075A	; 0x80075a <pxCurrentTCB>
 910:	f0 91 5b 07 	lds	r31, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 914:	86 89       	ldd	r24, Z+22	; 0x16
 916:	80 17       	cp	r24, r16
 918:	28 f4       	brcc	.+10     	; 0x924 <xTaskGenericCreate+0x1b6>
 91a:	41 de       	rcall	.-894    	; 0x59e <vPortYield>
 91c:	81 e0       	ldi	r24, 0x01	; 1
 91e:	09 c0       	rjmp	.+18     	; 0x932 <xTaskGenericCreate+0x1c4>
 920:	81 e0       	ldi	r24, 0x01	; 1
 922:	07 c0       	rjmp	.+14     	; 0x932 <xTaskGenericCreate+0x1c4>
 924:	81 e0       	ldi	r24, 0x01	; 1
 926:	05 c0       	rjmp	.+10     	; 0x932 <xTaskGenericCreate+0x1c4>
 928:	d8 8e       	std	Y+24, r13	; 0x18
 92a:	cf 8a       	std	Y+23, r12	; 0x17
 92c:	c6 01       	movw	r24, r12
 92e:	47 cf       	rjmp	.-370    	; 0x7be <xTaskGenericCreate+0x50>
 930:	8f ef       	ldi	r24, 0xFF	; 255
 932:	df 91       	pop	r29
 934:	cf 91       	pop	r28
 936:	1f 91       	pop	r17
 938:	0f 91       	pop	r16
 93a:	ff 90       	pop	r15
 93c:	ef 90       	pop	r14
 93e:	df 90       	pop	r13
 940:	cf 90       	pop	r12
 942:	bf 90       	pop	r11
 944:	af 90       	pop	r10
 946:	9f 90       	pop	r9
 948:	8f 90       	pop	r8
 94a:	7f 90       	pop	r7
 94c:	6f 90       	pop	r6
 94e:	5f 90       	pop	r5
 950:	4f 90       	pop	r4
 952:	08 95       	ret

00000954 <vTaskStartScheduler>:
 954:	af 92       	push	r10
 956:	bf 92       	push	r11
 958:	cf 92       	push	r12
 95a:	df 92       	push	r13
 95c:	ef 92       	push	r14
 95e:	ff 92       	push	r15
 960:	0f 93       	push	r16
 962:	a1 2c       	mov	r10, r1
 964:	b1 2c       	mov	r11, r1
 966:	c1 2c       	mov	r12, r1
 968:	d1 2c       	mov	r13, r1
 96a:	e1 2c       	mov	r14, r1
 96c:	f1 2c       	mov	r15, r1
 96e:	00 e0       	ldi	r16, 0x00	; 0
 970:	20 e0       	ldi	r18, 0x00	; 0
 972:	30 e0       	ldi	r19, 0x00	; 0
 974:	45 e5       	ldi	r20, 0x55	; 85
 976:	50 e0       	ldi	r21, 0x00	; 0
 978:	6e e1       	ldi	r22, 0x1E	; 30
 97a:	71 e0       	ldi	r23, 0x01	; 1
 97c:	86 e3       	ldi	r24, 0x36	; 54
 97e:	96 e0       	ldi	r25, 0x06	; 6
 980:	f6 de       	rcall	.-532    	; 0x76e <xTaskGenericCreate>
 982:	81 30       	cpi	r24, 0x01	; 1
 984:	41 f4       	brne	.+16     	; 0x996 <vTaskStartScheduler+0x42>
 986:	f8 94       	cli
 988:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xSchedulerRunning>
 98c:	10 92 0b 07 	sts	0x070B, r1	; 0x80070b <xTickCount+0x1>
 990:	10 92 0a 07 	sts	0x070A, r1	; 0x80070a <xTickCount>
 994:	ca dd       	rcall	.-1132   	; 0x52a <xPortStartScheduler>
 996:	0f 91       	pop	r16
 998:	ff 90       	pop	r15
 99a:	ef 90       	pop	r14
 99c:	df 90       	pop	r13
 99e:	cf 90       	pop	r12
 9a0:	bf 90       	pop	r11
 9a2:	af 90       	pop	r10
 9a4:	08 95       	ret

000009a6 <vTaskSuspendAll>:
 9a6:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxSchedulerSuspended>
 9aa:	8f 5f       	subi	r24, 0xFF	; 255
 9ac:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxSchedulerSuspended>
 9b0:	08 95       	ret

000009b2 <vTaskIncrementTick>:
 9b2:	0f 93       	push	r16
 9b4:	1f 93       	push	r17
 9b6:	cf 93       	push	r28
 9b8:	df 93       	push	r29
 9ba:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxSchedulerSuspended>
 9be:	81 11       	cpse	r24, r1
 9c0:	af c0       	rjmp	.+350    	; 0xb20 <vTaskIncrementTick+0x16e>
 9c2:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 9c6:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 9ca:	01 96       	adiw	r24, 0x01	; 1
 9cc:	90 93 0b 07 	sts	0x070B, r25	; 0x80070b <xTickCount+0x1>
 9d0:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <xTickCount>
 9d4:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 9d8:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 9dc:	89 2b       	or	r24, r25
 9de:	99 f5       	brne	.+102    	; 0xa46 <vTaskIncrementTick+0x94>
 9e0:	80 91 22 07 	lds	r24, 0x0722	; 0x800722 <pxDelayedTaskList>
 9e4:	90 91 23 07 	lds	r25, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 9e8:	20 91 20 07 	lds	r18, 0x0720	; 0x800720 <pxOverflowDelayedTaskList>
 9ec:	30 91 21 07 	lds	r19, 0x0721	; 0x800721 <pxOverflowDelayedTaskList+0x1>
 9f0:	30 93 23 07 	sts	0x0723, r19	; 0x800723 <pxDelayedTaskList+0x1>
 9f4:	20 93 22 07 	sts	0x0722, r18	; 0x800722 <pxDelayedTaskList>
 9f8:	90 93 21 07 	sts	0x0721, r25	; 0x800721 <pxOverflowDelayedTaskList+0x1>
 9fc:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <pxOverflowDelayedTaskList>
 a00:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xNumOfOverflows>
 a04:	8f 5f       	subi	r24, 0xFF	; 255
 a06:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xNumOfOverflows>
 a0a:	e0 91 22 07 	lds	r30, 0x0722	; 0x800722 <pxDelayedTaskList>
 a0e:	f0 91 23 07 	lds	r31, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 a12:	80 81       	ld	r24, Z
 a14:	81 11       	cpse	r24, r1
 a16:	07 c0       	rjmp	.+14     	; 0xa26 <vTaskIncrementTick+0x74>
 a18:	8f ef       	ldi	r24, 0xFF	; 255
 a1a:	9f ef       	ldi	r25, 0xFF	; 255
 a1c:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <xNextTaskUnblockTime+0x1>
 a20:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <xNextTaskUnblockTime>
 a24:	10 c0       	rjmp	.+32     	; 0xa46 <vTaskIncrementTick+0x94>
 a26:	e0 91 22 07 	lds	r30, 0x0722	; 0x800722 <pxDelayedTaskList>
 a2a:	f0 91 23 07 	lds	r31, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 a2e:	05 80       	ldd	r0, Z+5	; 0x05
 a30:	f6 81       	ldd	r31, Z+6	; 0x06
 a32:	e0 2d       	mov	r30, r0
 a34:	06 80       	ldd	r0, Z+6	; 0x06
 a36:	f7 81       	ldd	r31, Z+7	; 0x07
 a38:	e0 2d       	mov	r30, r0
 a3a:	82 81       	ldd	r24, Z+2	; 0x02
 a3c:	93 81       	ldd	r25, Z+3	; 0x03
 a3e:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <xNextTaskUnblockTime+0x1>
 a42:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <xNextTaskUnblockTime>
 a46:	20 91 0a 07 	lds	r18, 0x070A	; 0x80070a <xTickCount>
 a4a:	30 91 0b 07 	lds	r19, 0x070B	; 0x80070b <xTickCount+0x1>
 a4e:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <xNextTaskUnblockTime>
 a52:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <xNextTaskUnblockTime+0x1>
 a56:	28 17       	cp	r18, r24
 a58:	39 07       	cpc	r19, r25
 a5a:	08 f4       	brcc	.+2      	; 0xa5e <vTaskIncrementTick+0xac>
 a5c:	66 c0       	rjmp	.+204    	; 0xb2a <vTaskIncrementTick+0x178>
 a5e:	e0 91 22 07 	lds	r30, 0x0722	; 0x800722 <pxDelayedTaskList>
 a62:	f0 91 23 07 	lds	r31, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 a66:	80 81       	ld	r24, Z
 a68:	88 23       	and	r24, r24
 a6a:	99 f0       	breq	.+38     	; 0xa92 <vTaskIncrementTick+0xe0>
 a6c:	e0 91 22 07 	lds	r30, 0x0722	; 0x800722 <pxDelayedTaskList>
 a70:	f0 91 23 07 	lds	r31, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 a74:	05 80       	ldd	r0, Z+5	; 0x05
 a76:	f6 81       	ldd	r31, Z+6	; 0x06
 a78:	e0 2d       	mov	r30, r0
 a7a:	c6 81       	ldd	r28, Z+6	; 0x06
 a7c:	d7 81       	ldd	r29, Z+7	; 0x07
 a7e:	8a 81       	ldd	r24, Y+2	; 0x02
 a80:	9b 81       	ldd	r25, Y+3	; 0x03
 a82:	20 91 0a 07 	lds	r18, 0x070A	; 0x80070a <xTickCount>
 a86:	30 91 0b 07 	lds	r19, 0x070B	; 0x80070b <xTickCount+0x1>
 a8a:	28 17       	cp	r18, r24
 a8c:	39 07       	cpc	r19, r25
 a8e:	f8 f4       	brcc	.+62     	; 0xace <vTaskIncrementTick+0x11c>
 a90:	19 c0       	rjmp	.+50     	; 0xac4 <vTaskIncrementTick+0x112>
 a92:	8f ef       	ldi	r24, 0xFF	; 255
 a94:	9f ef       	ldi	r25, 0xFF	; 255
 a96:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <xNextTaskUnblockTime+0x1>
 a9a:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <xNextTaskUnblockTime>
 a9e:	45 c0       	rjmp	.+138    	; 0xb2a <vTaskIncrementTick+0x178>
 aa0:	e0 91 22 07 	lds	r30, 0x0722	; 0x800722 <pxDelayedTaskList>
 aa4:	f0 91 23 07 	lds	r31, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 aa8:	05 80       	ldd	r0, Z+5	; 0x05
 aaa:	f6 81       	ldd	r31, Z+6	; 0x06
 aac:	e0 2d       	mov	r30, r0
 aae:	c6 81       	ldd	r28, Z+6	; 0x06
 ab0:	d7 81       	ldd	r29, Z+7	; 0x07
 ab2:	8a 81       	ldd	r24, Y+2	; 0x02
 ab4:	9b 81       	ldd	r25, Y+3	; 0x03
 ab6:	20 91 0a 07 	lds	r18, 0x070A	; 0x80070a <xTickCount>
 aba:	30 91 0b 07 	lds	r19, 0x070B	; 0x80070b <xTickCount+0x1>
 abe:	28 17       	cp	r18, r24
 ac0:	39 07       	cpc	r19, r25
 ac2:	28 f4       	brcc	.+10     	; 0xace <vTaskIncrementTick+0x11c>
 ac4:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <xNextTaskUnblockTime+0x1>
 ac8:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <xNextTaskUnblockTime>
 acc:	2e c0       	rjmp	.+92     	; 0xb2a <vTaskIncrementTick+0x178>
 ace:	8e 01       	movw	r16, r28
 ad0:	0e 5f       	subi	r16, 0xFE	; 254
 ad2:	1f 4f       	sbci	r17, 0xFF	; 255
 ad4:	c8 01       	movw	r24, r16
 ad6:	ad db       	rcall	.-2214   	; 0x232 <vListRemove>
 ad8:	8c 89       	ldd	r24, Y+20	; 0x14
 ada:	9d 89       	ldd	r25, Y+21	; 0x15
 adc:	89 2b       	or	r24, r25
 ade:	19 f0       	breq	.+6      	; 0xae6 <vTaskIncrementTick+0x134>
 ae0:	ce 01       	movw	r24, r28
 ae2:	0c 96       	adiw	r24, 0x0c	; 12
 ae4:	a6 db       	rcall	.-2228   	; 0x232 <vListRemove>
 ae6:	2e 89       	ldd	r18, Y+22	; 0x16
 ae8:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTopReadyPriority>
 aec:	82 17       	cp	r24, r18
 aee:	10 f4       	brcc	.+4      	; 0xaf4 <vTaskIncrementTick+0x142>
 af0:	20 93 08 07 	sts	0x0708, r18	; 0x800708 <uxTopReadyPriority>
 af4:	30 e0       	ldi	r19, 0x00	; 0
 af6:	c9 01       	movw	r24, r18
 af8:	88 0f       	add	r24, r24
 afa:	99 1f       	adc	r25, r25
 afc:	88 0f       	add	r24, r24
 afe:	99 1f       	adc	r25, r25
 b00:	88 0f       	add	r24, r24
 b02:	99 1f       	adc	r25, r25
 b04:	82 0f       	add	r24, r18
 b06:	93 1f       	adc	r25, r19
 b08:	b8 01       	movw	r22, r16
 b0a:	8a 5c       	subi	r24, 0xCA	; 202
 b0c:	98 4f       	sbci	r25, 0xF8	; 248
 b0e:	2f db       	rcall	.-2466   	; 0x16e <vListInsertEnd>
 b10:	e0 91 22 07 	lds	r30, 0x0722	; 0x800722 <pxDelayedTaskList>
 b14:	f0 91 23 07 	lds	r31, 0x0723	; 0x800723 <pxDelayedTaskList+0x1>
 b18:	80 81       	ld	r24, Z
 b1a:	81 11       	cpse	r24, r1
 b1c:	c1 cf       	rjmp	.-126    	; 0xaa0 <vTaskIncrementTick+0xee>
 b1e:	b9 cf       	rjmp	.-142    	; 0xa92 <vTaskIncrementTick+0xe0>
 b20:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxMissedTicks>
 b24:	8f 5f       	subi	r24, 0xFF	; 255
 b26:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxMissedTicks>
 b2a:	df 91       	pop	r29
 b2c:	cf 91       	pop	r28
 b2e:	1f 91       	pop	r17
 b30:	0f 91       	pop	r16
 b32:	08 95       	ret

00000b34 <xTaskResumeAll>:
 b34:	cf 92       	push	r12
 b36:	df 92       	push	r13
 b38:	ef 92       	push	r14
 b3a:	ff 92       	push	r15
 b3c:	0f 93       	push	r16
 b3e:	1f 93       	push	r17
 b40:	cf 93       	push	r28
 b42:	df 93       	push	r29
 b44:	0f b6       	in	r0, 0x3f	; 63
 b46:	f8 94       	cli
 b48:	0f 92       	push	r0
 b4a:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxSchedulerSuspended>
 b4e:	81 50       	subi	r24, 0x01	; 1
 b50:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxSchedulerSuspended>
 b54:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxSchedulerSuspended>
 b58:	81 11       	cpse	r24, r1
 b5a:	5f c0       	rjmp	.+190    	; 0xc1a <xTaskResumeAll+0xe6>
 b5c:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 b60:	81 11       	cpse	r24, r1
 b62:	2f c0       	rjmp	.+94     	; 0xbc2 <xTaskResumeAll+0x8e>
 b64:	5d c0       	rjmp	.+186    	; 0xc20 <xTaskResumeAll+0xec>
 b66:	d7 01       	movw	r26, r14
 b68:	15 96       	adiw	r26, 0x05	; 5
 b6a:	ed 91       	ld	r30, X+
 b6c:	fc 91       	ld	r31, X
 b6e:	16 97       	sbiw	r26, 0x06	; 6
 b70:	c6 81       	ldd	r28, Z+6	; 0x06
 b72:	d7 81       	ldd	r29, Z+7	; 0x07
 b74:	ce 01       	movw	r24, r28
 b76:	0c 96       	adiw	r24, 0x0c	; 12
 b78:	5c db       	rcall	.-2376   	; 0x232 <vListRemove>
 b7a:	8e 01       	movw	r16, r28
 b7c:	0e 5f       	subi	r16, 0xFE	; 254
 b7e:	1f 4f       	sbci	r17, 0xFF	; 255
 b80:	c8 01       	movw	r24, r16
 b82:	57 db       	rcall	.-2386   	; 0x232 <vListRemove>
 b84:	2e 89       	ldd	r18, Y+22	; 0x16
 b86:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTopReadyPriority>
 b8a:	82 17       	cp	r24, r18
 b8c:	10 f4       	brcc	.+4      	; 0xb92 <xTaskResumeAll+0x5e>
 b8e:	20 93 08 07 	sts	0x0708, r18	; 0x800708 <uxTopReadyPriority>
 b92:	30 e0       	ldi	r19, 0x00	; 0
 b94:	c9 01       	movw	r24, r18
 b96:	88 0f       	add	r24, r24
 b98:	99 1f       	adc	r25, r25
 b9a:	88 0f       	add	r24, r24
 b9c:	99 1f       	adc	r25, r25
 b9e:	88 0f       	add	r24, r24
 ba0:	99 1f       	adc	r25, r25
 ba2:	82 0f       	add	r24, r18
 ba4:	93 1f       	adc	r25, r19
 ba6:	b8 01       	movw	r22, r16
 ba8:	8a 5c       	subi	r24, 0xCA	; 202
 baa:	98 4f       	sbci	r25, 0xF8	; 248
 bac:	e0 da       	rcall	.-2624   	; 0x16e <vListInsertEnd>
 bae:	e0 91 5a 07 	lds	r30, 0x075A	; 0x80075a <pxCurrentTCB>
 bb2:	f0 91 5b 07 	lds	r31, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 bb6:	9e 89       	ldd	r25, Y+22	; 0x16
 bb8:	86 89       	ldd	r24, Z+22	; 0x16
 bba:	98 17       	cp	r25, r24
 bbc:	58 f0       	brcs	.+22     	; 0xbd4 <xTaskResumeAll+0xa0>
 bbe:	dc 2c       	mov	r13, r12
 bc0:	09 c0       	rjmp	.+18     	; 0xbd4 <xTaskResumeAll+0xa0>
 bc2:	d1 2c       	mov	r13, r1
 bc4:	0f 2e       	mov	r0, r31
 bc6:	f7 e1       	ldi	r31, 0x17	; 23
 bc8:	ef 2e       	mov	r14, r31
 bca:	f7 e0       	ldi	r31, 0x07	; 7
 bcc:	ff 2e       	mov	r15, r31
 bce:	f0 2d       	mov	r31, r0
 bd0:	cc 24       	eor	r12, r12
 bd2:	c3 94       	inc	r12
 bd4:	f7 01       	movw	r30, r14
 bd6:	80 81       	ld	r24, Z
 bd8:	81 11       	cpse	r24, r1
 bda:	c5 cf       	rjmp	.-118    	; 0xb66 <xTaskResumeAll+0x32>
 bdc:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxMissedTicks>
 be0:	88 23       	and	r24, r24
 be2:	79 f0       	breq	.+30     	; 0xc02 <xTaskResumeAll+0xce>
 be4:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxMissedTicks>
 be8:	88 23       	and	r24, r24
 bea:	91 f0       	breq	.+36     	; 0xc10 <xTaskResumeAll+0xdc>
 bec:	e2 de       	rcall	.-572    	; 0x9b2 <vTaskIncrementTick>
 bee:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxMissedTicks>
 bf2:	81 50       	subi	r24, 0x01	; 1
 bf4:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxMissedTicks>
 bf8:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxMissedTicks>
 bfc:	81 11       	cpse	r24, r1
 bfe:	f6 cf       	rjmp	.-20     	; 0xbec <xTaskResumeAll+0xb8>
 c00:	07 c0       	rjmp	.+14     	; 0xc10 <xTaskResumeAll+0xdc>
 c02:	f1 e0       	ldi	r31, 0x01	; 1
 c04:	df 16       	cp	r13, r31
 c06:	21 f0       	breq	.+8      	; 0xc10 <xTaskResumeAll+0xdc>
 c08:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xMissedYield>
 c0c:	81 30       	cpi	r24, 0x01	; 1
 c0e:	39 f4       	brne	.+14     	; 0xc1e <xTaskResumeAll+0xea>
 c10:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xMissedYield>
 c14:	c4 dc       	rcall	.-1656   	; 0x59e <vPortYield>
 c16:	81 e0       	ldi	r24, 0x01	; 1
 c18:	03 c0       	rjmp	.+6      	; 0xc20 <xTaskResumeAll+0xec>
 c1a:	80 e0       	ldi	r24, 0x00	; 0
 c1c:	01 c0       	rjmp	.+2      	; 0xc20 <xTaskResumeAll+0xec>
 c1e:	80 e0       	ldi	r24, 0x00	; 0
 c20:	0f 90       	pop	r0
 c22:	0f be       	out	0x3f, r0	; 63
 c24:	df 91       	pop	r29
 c26:	cf 91       	pop	r28
 c28:	1f 91       	pop	r17
 c2a:	0f 91       	pop	r16
 c2c:	ff 90       	pop	r15
 c2e:	ef 90       	pop	r14
 c30:	df 90       	pop	r13
 c32:	cf 90       	pop	r12
 c34:	08 95       	ret

00000c36 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 c36:	cf 93       	push	r28
 c38:	df 93       	push	r29
 c3a:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 c3c:	89 2b       	or	r24, r25
 c3e:	91 f0       	breq	.+36     	; 0xc64 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
 c40:	b2 de       	rcall	.-668    	; 0x9a6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 c42:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 c46:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 c4a:	c8 0f       	add	r28, r24
 c4c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 c4e:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <pxCurrentTCB>
 c52:	90 91 5b 07 	lds	r25, 0x075B	; 0x80075b <pxCurrentTCB+0x1>
 c56:	02 96       	adiw	r24, 0x02	; 2
 c58:	ec da       	rcall	.-2600   	; 0x232 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 c5a:	ce 01       	movw	r24, r28
 c5c:	53 dd       	rcall	.-1370   	; 0x704 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 c5e:	6a df       	rcall	.-300    	; 0xb34 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 c60:	81 11       	cpse	r24, r1
 c62:	01 c0       	rjmp	.+2      	; 0xc66 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
 c64:	9c dc       	rcall	.-1736   	; 0x59e <vPortYield>
		}
	}
 c66:	df 91       	pop	r29
 c68:	cf 91       	pop	r28
 c6a:	08 95       	ret

00000c6c <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c6c:	0f 2e       	mov	r0, r31
 c6e:	fe e0       	ldi	r31, 0x0E	; 14
 c70:	ef 2e       	mov	r14, r31
 c72:	f7 e0       	ldi	r31, 0x07	; 7
 c74:	ff 2e       	mov	r15, r31
 c76:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 c78:	c6 e3       	ldi	r28, 0x36	; 54
 c7a:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 c7c:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxTasksDeleted>
 c80:	88 23       	and	r24, r24
 c82:	29 f1       	breq	.+74     	; 0xcce <prvIdleTask+0x62>
		{
			vTaskSuspendAll();
 c84:	90 de       	rcall	.-736    	; 0x9a6 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c86:	d7 01       	movw	r26, r14
 c88:	1c 91       	ld	r17, X
			xTaskResumeAll();
 c8a:	54 df       	rcall	.-344    	; 0xb34 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 c8c:	11 23       	and	r17, r17
 c8e:	f9 f0       	breq	.+62     	; 0xcce <prvIdleTask+0x62>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 c90:	0f b6       	in	r0, 0x3f	; 63
 c92:	f8 94       	cli
 c94:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 c96:	d7 01       	movw	r26, r14
 c98:	15 96       	adiw	r26, 0x05	; 5
 c9a:	ed 91       	ld	r30, X+
 c9c:	fc 91       	ld	r31, X
 c9e:	16 97       	sbiw	r26, 0x06	; 6
 ca0:	06 81       	ldd	r16, Z+6	; 0x06
 ca2:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
 ca4:	c8 01       	movw	r24, r16
 ca6:	02 96       	adiw	r24, 0x02	; 2
 ca8:	c4 da       	rcall	.-2680   	; 0x232 <vListRemove>
					--uxCurrentNumberOfTasks;
 caa:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 cae:	81 50       	subi	r24, 0x01	; 1
 cb0:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 cb4:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxTasksDeleted>
 cb8:	81 50       	subi	r24, 0x01	; 1
 cba:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 cbe:	0f 90       	pop	r0
 cc0:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 cc2:	f8 01       	movw	r30, r16
 cc4:	87 89       	ldd	r24, Z+23	; 0x17
 cc6:	90 8d       	ldd	r25, Z+24	; 0x18
 cc8:	3f da       	rcall	.-2946   	; 0x148 <vPortFree>
		vPortFree( pxTCB );
 cca:	c8 01       	movw	r24, r16
 ccc:	3d da       	rcall	.-2950   	; 0x148 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 cce:	88 81       	ld	r24, Y
 cd0:	82 30       	cpi	r24, 0x02	; 2
 cd2:	a0 f2       	brcs	.-88     	; 0xc7c <prvIdleTask+0x10>
			{
				taskYIELD();
 cd4:	64 dc       	rcall	.-1848   	; 0x59e <vPortYield>
 cd6:	d2 cf       	rjmp	.-92     	; 0xc7c <prvIdleTask+0x10>

00000cd8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 cd8:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxSchedulerSuspended>
 cdc:	81 11       	cpse	r24, r1
 cde:	13 c0       	rjmp	.+38     	; 0xd06 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 ce0:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTopReadyPriority>
 ce4:	90 e0       	ldi	r25, 0x00	; 0
 ce6:	fc 01       	movw	r30, r24
 ce8:	ee 0f       	add	r30, r30
 cea:	ff 1f       	adc	r31, r31
 cec:	ee 0f       	add	r30, r30
 cee:	ff 1f       	adc	r31, r31
 cf0:	ee 0f       	add	r30, r30
 cf2:	ff 1f       	adc	r31, r31
 cf4:	8e 0f       	add	r24, r30
 cf6:	9f 1f       	adc	r25, r31
 cf8:	fc 01       	movw	r30, r24
 cfa:	ea 5c       	subi	r30, 0xCA	; 202
 cfc:	f8 4f       	sbci	r31, 0xF8	; 248
 cfe:	80 81       	ld	r24, Z
 d00:	88 23       	and	r24, r24
 d02:	29 f0       	breq	.+10     	; 0xd0e <vTaskSwitchContext+0x36>
 d04:	1b c0       	rjmp	.+54     	; 0xd3c <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 d06:	81 e0       	ldi	r24, 0x01	; 1
 d08:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xMissedYield>
 d0c:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 d0e:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTopReadyPriority>
 d12:	81 50       	subi	r24, 0x01	; 1
 d14:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 d18:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTopReadyPriority>
 d1c:	90 e0       	ldi	r25, 0x00	; 0
 d1e:	fc 01       	movw	r30, r24
 d20:	ee 0f       	add	r30, r30
 d22:	ff 1f       	adc	r31, r31
 d24:	ee 0f       	add	r30, r30
 d26:	ff 1f       	adc	r31, r31
 d28:	ee 0f       	add	r30, r30
 d2a:	ff 1f       	adc	r31, r31
 d2c:	8e 0f       	add	r24, r30
 d2e:	9f 1f       	adc	r25, r31
 d30:	fc 01       	movw	r30, r24
 d32:	ea 5c       	subi	r30, 0xCA	; 202
 d34:	f8 4f       	sbci	r31, 0xF8	; 248
 d36:	80 81       	ld	r24, Z
 d38:	88 23       	and	r24, r24
 d3a:	49 f3       	breq	.-46     	; 0xd0e <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 d3c:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTopReadyPriority>
 d40:	90 e0       	ldi	r25, 0x00	; 0
 d42:	9c 01       	movw	r18, r24
 d44:	22 0f       	add	r18, r18
 d46:	33 1f       	adc	r19, r19
 d48:	22 0f       	add	r18, r18
 d4a:	33 1f       	adc	r19, r19
 d4c:	22 0f       	add	r18, r18
 d4e:	33 1f       	adc	r19, r19
 d50:	28 0f       	add	r18, r24
 d52:	39 1f       	adc	r19, r25
 d54:	d9 01       	movw	r26, r18
 d56:	aa 5c       	subi	r26, 0xCA	; 202
 d58:	b8 4f       	sbci	r27, 0xF8	; 248
 d5a:	11 96       	adiw	r26, 0x01	; 1
 d5c:	ed 91       	ld	r30, X+
 d5e:	fc 91       	ld	r31, X
 d60:	12 97       	sbiw	r26, 0x02	; 2
 d62:	02 80       	ldd	r0, Z+2	; 0x02
 d64:	f3 81       	ldd	r31, Z+3	; 0x03
 d66:	e0 2d       	mov	r30, r0
 d68:	12 96       	adiw	r26, 0x02	; 2
 d6a:	fc 93       	st	X, r31
 d6c:	ee 93       	st	-X, r30
 d6e:	11 97       	sbiw	r26, 0x01	; 1
 d70:	27 5c       	subi	r18, 0xC7	; 199
 d72:	38 4f       	sbci	r19, 0xF8	; 248
 d74:	e2 17       	cp	r30, r18
 d76:	f3 07       	cpc	r31, r19
 d78:	29 f4       	brne	.+10     	; 0xd84 <vTaskSwitchContext+0xac>
 d7a:	22 81       	ldd	r18, Z+2	; 0x02
 d7c:	33 81       	ldd	r19, Z+3	; 0x03
 d7e:	fd 01       	movw	r30, r26
 d80:	32 83       	std	Z+2, r19	; 0x02
 d82:	21 83       	std	Z+1, r18	; 0x01
 d84:	fc 01       	movw	r30, r24
 d86:	ee 0f       	add	r30, r30
 d88:	ff 1f       	adc	r31, r31
 d8a:	ee 0f       	add	r30, r30
 d8c:	ff 1f       	adc	r31, r31
 d8e:	ee 0f       	add	r30, r30
 d90:	ff 1f       	adc	r31, r31
 d92:	8e 0f       	add	r24, r30
 d94:	9f 1f       	adc	r25, r31
 d96:	fc 01       	movw	r30, r24
 d98:	ea 5c       	subi	r30, 0xCA	; 202
 d9a:	f8 4f       	sbci	r31, 0xF8	; 248
 d9c:	01 80       	ldd	r0, Z+1	; 0x01
 d9e:	f2 81       	ldd	r31, Z+2	; 0x02
 da0:	e0 2d       	mov	r30, r0
 da2:	86 81       	ldd	r24, Z+6	; 0x06
 da4:	97 81       	ldd	r25, Z+7	; 0x07
 da6:	90 93 5b 07 	sts	0x075B, r25	; 0x80075b <pxCurrentTCB+0x1>
 daa:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <pxCurrentTCB>
 dae:	08 95       	ret

00000db0 <__divmodhi4>:
 db0:	97 fb       	bst	r25, 7
 db2:	07 2e       	mov	r0, r23
 db4:	16 f4       	brtc	.+4      	; 0xdba <__divmodhi4+0xa>
 db6:	00 94       	com	r0
 db8:	06 d0       	rcall	.+12     	; 0xdc6 <__divmodhi4_neg1>
 dba:	77 fd       	sbrc	r23, 7
 dbc:	08 d0       	rcall	.+16     	; 0xdce <__divmodhi4_neg2>
 dbe:	14 d0       	rcall	.+40     	; 0xde8 <__udivmodhi4>
 dc0:	07 fc       	sbrc	r0, 7
 dc2:	05 d0       	rcall	.+10     	; 0xdce <__divmodhi4_neg2>
 dc4:	3e f4       	brtc	.+14     	; 0xdd4 <__divmodhi4_exit>

00000dc6 <__divmodhi4_neg1>:
 dc6:	90 95       	com	r25
 dc8:	81 95       	neg	r24
 dca:	9f 4f       	sbci	r25, 0xFF	; 255
 dcc:	08 95       	ret

00000dce <__divmodhi4_neg2>:
 dce:	70 95       	com	r23
 dd0:	61 95       	neg	r22
 dd2:	7f 4f       	sbci	r23, 0xFF	; 255

00000dd4 <__divmodhi4_exit>:
 dd4:	08 95       	ret

00000dd6 <__tablejump2__>:
 dd6:	ee 0f       	add	r30, r30
 dd8:	ff 1f       	adc	r31, r31
 dda:	00 24       	eor	r0, r0
 ddc:	00 1c       	adc	r0, r0
 dde:	0b be       	out	0x3b, r0	; 59
 de0:	07 90       	elpm	r0, Z+
 de2:	f6 91       	elpm	r31, Z
 de4:	e0 2d       	mov	r30, r0
 de6:	09 94       	ijmp

00000de8 <__udivmodhi4>:
 de8:	aa 1b       	sub	r26, r26
 dea:	bb 1b       	sub	r27, r27
 dec:	51 e1       	ldi	r21, 0x11	; 17
 dee:	07 c0       	rjmp	.+14     	; 0xdfe <__udivmodhi4_ep>

00000df0 <__udivmodhi4_loop>:
 df0:	aa 1f       	adc	r26, r26
 df2:	bb 1f       	adc	r27, r27
 df4:	a6 17       	cp	r26, r22
 df6:	b7 07       	cpc	r27, r23
 df8:	10 f0       	brcs	.+4      	; 0xdfe <__udivmodhi4_ep>
 dfa:	a6 1b       	sub	r26, r22
 dfc:	b7 0b       	sbc	r27, r23

00000dfe <__udivmodhi4_ep>:
 dfe:	88 1f       	adc	r24, r24
 e00:	99 1f       	adc	r25, r25
 e02:	5a 95       	dec	r21
 e04:	a9 f7       	brne	.-22     	; 0xdf0 <__udivmodhi4_loop>
 e06:	80 95       	com	r24
 e08:	90 95       	com	r25
 e0a:	bc 01       	movw	r22, r24
 e0c:	cd 01       	movw	r24, r26
 e0e:	08 95       	ret

00000e10 <do_rand>:
 e10:	8f 92       	push	r8
 e12:	9f 92       	push	r9
 e14:	af 92       	push	r10
 e16:	bf 92       	push	r11
 e18:	cf 92       	push	r12
 e1a:	df 92       	push	r13
 e1c:	ef 92       	push	r14
 e1e:	ff 92       	push	r15
 e20:	cf 93       	push	r28
 e22:	df 93       	push	r29
 e24:	ec 01       	movw	r28, r24
 e26:	68 81       	ld	r22, Y
 e28:	79 81       	ldd	r23, Y+1	; 0x01
 e2a:	8a 81       	ldd	r24, Y+2	; 0x02
 e2c:	9b 81       	ldd	r25, Y+3	; 0x03
 e2e:	61 15       	cp	r22, r1
 e30:	71 05       	cpc	r23, r1
 e32:	81 05       	cpc	r24, r1
 e34:	91 05       	cpc	r25, r1
 e36:	21 f4       	brne	.+8      	; 0xe40 <do_rand+0x30>
 e38:	64 e2       	ldi	r22, 0x24	; 36
 e3a:	79 ed       	ldi	r23, 0xD9	; 217
 e3c:	8b e5       	ldi	r24, 0x5B	; 91
 e3e:	97 e0       	ldi	r25, 0x07	; 7
 e40:	2d e1       	ldi	r18, 0x1D	; 29
 e42:	33 ef       	ldi	r19, 0xF3	; 243
 e44:	41 e0       	ldi	r20, 0x01	; 1
 e46:	50 e0       	ldi	r21, 0x00	; 0
 e48:	4e d0       	rcall	.+156    	; 0xee6 <__divmodsi4>
 e4a:	49 01       	movw	r8, r18
 e4c:	5a 01       	movw	r10, r20
 e4e:	9b 01       	movw	r18, r22
 e50:	ac 01       	movw	r20, r24
 e52:	a7 ea       	ldi	r26, 0xA7	; 167
 e54:	b1 e4       	ldi	r27, 0x41	; 65
 e56:	63 d0       	rcall	.+198    	; 0xf1e <__muluhisi3>
 e58:	6b 01       	movw	r12, r22
 e5a:	7c 01       	movw	r14, r24
 e5c:	ac ee       	ldi	r26, 0xEC	; 236
 e5e:	b4 ef       	ldi	r27, 0xF4	; 244
 e60:	a5 01       	movw	r20, r10
 e62:	94 01       	movw	r18, r8
 e64:	68 d0       	rcall	.+208    	; 0xf36 <__mulohisi3>
 e66:	dc 01       	movw	r26, r24
 e68:	cb 01       	movw	r24, r22
 e6a:	8c 0d       	add	r24, r12
 e6c:	9d 1d       	adc	r25, r13
 e6e:	ae 1d       	adc	r26, r14
 e70:	bf 1d       	adc	r27, r15
 e72:	b7 ff       	sbrs	r27, 7
 e74:	03 c0       	rjmp	.+6      	; 0xe7c <do_rand+0x6c>
 e76:	01 97       	sbiw	r24, 0x01	; 1
 e78:	a1 09       	sbc	r26, r1
 e7a:	b0 48       	sbci	r27, 0x80	; 128
 e7c:	88 83       	st	Y, r24
 e7e:	99 83       	std	Y+1, r25	; 0x01
 e80:	aa 83       	std	Y+2, r26	; 0x02
 e82:	bb 83       	std	Y+3, r27	; 0x03
 e84:	9f 77       	andi	r25, 0x7F	; 127
 e86:	df 91       	pop	r29
 e88:	cf 91       	pop	r28
 e8a:	ff 90       	pop	r15
 e8c:	ef 90       	pop	r14
 e8e:	df 90       	pop	r13
 e90:	cf 90       	pop	r12
 e92:	bf 90       	pop	r11
 e94:	af 90       	pop	r10
 e96:	9f 90       	pop	r9
 e98:	8f 90       	pop	r8
 e9a:	08 95       	ret

00000e9c <rand_r>:
 e9c:	b9 cf       	rjmp	.-142    	; 0xe10 <do_rand>

00000e9e <rand>:
 e9e:	80 e0       	ldi	r24, 0x00	; 0
 ea0:	91 e0       	ldi	r25, 0x01	; 1
 ea2:	b6 cf       	rjmp	.-148    	; 0xe10 <do_rand>

00000ea4 <srand>:
 ea4:	a0 e0       	ldi	r26, 0x00	; 0
 ea6:	b0 e0       	ldi	r27, 0x00	; 0
 ea8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 eac:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 eb0:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
 eb4:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
 eb8:	08 95       	ret

00000eba <memset>:
 eba:	dc 01       	movw	r26, r24
 ebc:	01 c0       	rjmp	.+2      	; 0xec0 <memset+0x6>
 ebe:	6d 93       	st	X+, r22
 ec0:	41 50       	subi	r20, 0x01	; 1
 ec2:	50 40       	sbci	r21, 0x00	; 0
 ec4:	e0 f7       	brcc	.-8      	; 0xebe <memset+0x4>
 ec6:	08 95       	ret

00000ec8 <strncpy>:
 ec8:	fb 01       	movw	r30, r22
 eca:	dc 01       	movw	r26, r24
 ecc:	41 50       	subi	r20, 0x01	; 1
 ece:	50 40       	sbci	r21, 0x00	; 0
 ed0:	48 f0       	brcs	.+18     	; 0xee4 <strncpy+0x1c>
 ed2:	01 90       	ld	r0, Z+
 ed4:	0d 92       	st	X+, r0
 ed6:	00 20       	and	r0, r0
 ed8:	c9 f7       	brne	.-14     	; 0xecc <strncpy+0x4>
 eda:	01 c0       	rjmp	.+2      	; 0xede <strncpy+0x16>
 edc:	1d 92       	st	X+, r1
 ede:	41 50       	subi	r20, 0x01	; 1
 ee0:	50 40       	sbci	r21, 0x00	; 0
 ee2:	e0 f7       	brcc	.-8      	; 0xedc <strncpy+0x14>
 ee4:	08 95       	ret

00000ee6 <__divmodsi4>:
 ee6:	05 2e       	mov	r0, r21
 ee8:	97 fb       	bst	r25, 7
 eea:	16 f4       	brtc	.+4      	; 0xef0 <__divmodsi4+0xa>
 eec:	00 94       	com	r0
 eee:	0f d0       	rcall	.+30     	; 0xf0e <__negsi2>
 ef0:	57 fd       	sbrc	r21, 7
 ef2:	05 d0       	rcall	.+10     	; 0xefe <__divmodsi4_neg2>
 ef4:	24 d0       	rcall	.+72     	; 0xf3e <__udivmodsi4>
 ef6:	07 fc       	sbrc	r0, 7
 ef8:	02 d0       	rcall	.+4      	; 0xefe <__divmodsi4_neg2>
 efa:	46 f4       	brtc	.+16     	; 0xf0c <__divmodsi4_exit>
 efc:	08 c0       	rjmp	.+16     	; 0xf0e <__negsi2>

00000efe <__divmodsi4_neg2>:
 efe:	50 95       	com	r21
 f00:	40 95       	com	r20
 f02:	30 95       	com	r19
 f04:	21 95       	neg	r18
 f06:	3f 4f       	sbci	r19, 0xFF	; 255
 f08:	4f 4f       	sbci	r20, 0xFF	; 255
 f0a:	5f 4f       	sbci	r21, 0xFF	; 255

00000f0c <__divmodsi4_exit>:
 f0c:	08 95       	ret

00000f0e <__negsi2>:
 f0e:	90 95       	com	r25
 f10:	80 95       	com	r24
 f12:	70 95       	com	r23
 f14:	61 95       	neg	r22
 f16:	7f 4f       	sbci	r23, 0xFF	; 255
 f18:	8f 4f       	sbci	r24, 0xFF	; 255
 f1a:	9f 4f       	sbci	r25, 0xFF	; 255
 f1c:	08 95       	ret

00000f1e <__muluhisi3>:
 f1e:	31 d0       	rcall	.+98     	; 0xf82 <__umulhisi3>
 f20:	a5 9f       	mul	r26, r21
 f22:	90 0d       	add	r25, r0
 f24:	b4 9f       	mul	r27, r20
 f26:	90 0d       	add	r25, r0
 f28:	a4 9f       	mul	r26, r20
 f2a:	80 0d       	add	r24, r0
 f2c:	91 1d       	adc	r25, r1
 f2e:	11 24       	eor	r1, r1
 f30:	08 95       	ret

00000f32 <__mulshisi3>:
 f32:	b7 ff       	sbrs	r27, 7
 f34:	f4 cf       	rjmp	.-24     	; 0xf1e <__muluhisi3>

00000f36 <__mulohisi3>:
 f36:	f3 df       	rcall	.-26     	; 0xf1e <__muluhisi3>
 f38:	82 1b       	sub	r24, r18
 f3a:	93 0b       	sbc	r25, r19
 f3c:	08 95       	ret

00000f3e <__udivmodsi4>:
 f3e:	a1 e2       	ldi	r26, 0x21	; 33
 f40:	1a 2e       	mov	r1, r26
 f42:	aa 1b       	sub	r26, r26
 f44:	bb 1b       	sub	r27, r27
 f46:	fd 01       	movw	r30, r26
 f48:	0d c0       	rjmp	.+26     	; 0xf64 <__udivmodsi4_ep>

00000f4a <__udivmodsi4_loop>:
 f4a:	aa 1f       	adc	r26, r26
 f4c:	bb 1f       	adc	r27, r27
 f4e:	ee 1f       	adc	r30, r30
 f50:	ff 1f       	adc	r31, r31
 f52:	a2 17       	cp	r26, r18
 f54:	b3 07       	cpc	r27, r19
 f56:	e4 07       	cpc	r30, r20
 f58:	f5 07       	cpc	r31, r21
 f5a:	20 f0       	brcs	.+8      	; 0xf64 <__udivmodsi4_ep>
 f5c:	a2 1b       	sub	r26, r18
 f5e:	b3 0b       	sbc	r27, r19
 f60:	e4 0b       	sbc	r30, r20
 f62:	f5 0b       	sbc	r31, r21

00000f64 <__udivmodsi4_ep>:
 f64:	66 1f       	adc	r22, r22
 f66:	77 1f       	adc	r23, r23
 f68:	88 1f       	adc	r24, r24
 f6a:	99 1f       	adc	r25, r25
 f6c:	1a 94       	dec	r1
 f6e:	69 f7       	brne	.-38     	; 0xf4a <__udivmodsi4_loop>
 f70:	60 95       	com	r22
 f72:	70 95       	com	r23
 f74:	80 95       	com	r24
 f76:	90 95       	com	r25
 f78:	9b 01       	movw	r18, r22
 f7a:	ac 01       	movw	r20, r24
 f7c:	bd 01       	movw	r22, r26
 f7e:	cf 01       	movw	r24, r30
 f80:	08 95       	ret

00000f82 <__umulhisi3>:
 f82:	a2 9f       	mul	r26, r18
 f84:	b0 01       	movw	r22, r0
 f86:	b3 9f       	mul	r27, r19
 f88:	c0 01       	movw	r24, r0
 f8a:	a3 9f       	mul	r26, r19
 f8c:	70 0d       	add	r23, r0
 f8e:	81 1d       	adc	r24, r1
 f90:	11 24       	eor	r1, r1
 f92:	91 1d       	adc	r25, r1
 f94:	b2 9f       	mul	r27, r18
 f96:	70 0d       	add	r23, r0
 f98:	81 1d       	adc	r24, r1
 f9a:	11 24       	eor	r1, r1
 f9c:	91 1d       	adc	r25, r1
 f9e:	08 95       	ret

00000fa0 <_exit>:
 fa0:	f8 94       	cli

00000fa2 <__stop_program>:
 fa2:	ff cf       	rjmp	.-2      	; 0xfa2 <__stop_program>
